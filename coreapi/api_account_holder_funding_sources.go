/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AccountHolderFundingSourcesAPIService AccountHolderFundingSourcesAPI service
type AccountHolderFundingSourcesAPIService service

type ApiGetFundingsourcesAchFundingsourcetokenRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	fundingSourceToken string
}

func (r ApiGetFundingsourcesAchFundingsourcetokenRequest) Execute() (*AchResponseModel, *http.Response, error) {
	return r.ApiService.GetFundingsourcesAchFundingsourcetokenExecute(r)
}

/*
GetFundingsourcesAchFundingsourcetoken Retrieve ACH source

Retrieve a specific ACH funding source.

The response body returns details about the account, including the verification status.
Possible ACH verification status values are: `ACH_FAILED`, `ACH_VERIFIED`, and `VERIFICATION_PENDING`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fundingSourceToken Unique identifier of the funding source.  Send a `GET` request to `/fundingsources/user/{user_token}` to retrieve existing funding source tokens for a user or to `/fundingsources/business/{business_token}` to retrieve existing funding source tokens for a business.
 @return ApiGetFundingsourcesAchFundingsourcetokenRequest
*/
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesAchFundingsourcetoken(ctx context.Context, fundingSourceToken string) ApiGetFundingsourcesAchFundingsourcetokenRequest {
	return ApiGetFundingsourcesAchFundingsourcetokenRequest{
		ApiService: a,
		ctx: ctx,
		fundingSourceToken: fundingSourceToken,
	}
}

// Execute executes the request
//  @return AchResponseModel
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesAchFundingsourcetokenExecute(r ApiGetFundingsourcesAchFundingsourcetokenRequest) (*AchResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.GetFundingsourcesAchFundingsourcetoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/ach/{funding_source_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"funding_source_token"+"}", url.PathEscape(parameterValueToString(r.fundingSourceToken, "fundingSourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFundingsourcesAchFundingsourcetokenVerificationamountsRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	fundingSourceToken string
}

func (r ApiGetFundingsourcesAchFundingsourcetokenVerificationamountsRequest) Execute() (*AchVerificationModel, *http.Response, error) {
	return r.ApiService.GetFundingsourcesAchFundingsourcetokenVerificationamountsExecute(r)
}

/*
GetFundingsourcesAchFundingsourcetokenVerificationamounts Retrieve ACH verification amounts

In your sandbox environment, retrieve the amounts used to verify the association with your ACH account.

Use this endpoint for testing purposes only.
In production, verification amounts are retrieved from the bank statement of the account holder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fundingSourceToken Unique identifier of the funding source.  Send a `GET` request to `/fundingsources/user/{user_token}` to retrieve existing funding source tokens for a user or to `/fundingsources/business/{business_token}` to retrieve existing funding source tokens for a business.
 @return ApiGetFundingsourcesAchFundingsourcetokenVerificationamountsRequest
*/
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesAchFundingsourcetokenVerificationamounts(ctx context.Context, fundingSourceToken string) ApiGetFundingsourcesAchFundingsourcetokenVerificationamountsRequest {
	return ApiGetFundingsourcesAchFundingsourcetokenVerificationamountsRequest{
		ApiService: a,
		ctx: ctx,
		fundingSourceToken: fundingSourceToken,
	}
}

// Execute executes the request
//  @return AchVerificationModel
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesAchFundingsourcetokenVerificationamountsExecute(r ApiGetFundingsourcesAchFundingsourcetokenVerificationamountsRequest) (*AchVerificationModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchVerificationModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.GetFundingsourcesAchFundingsourcetokenVerificationamounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/ach/{funding_source_token}/verificationamounts"
	localVarPath = strings.Replace(localVarPath, "{"+"funding_source_token"+"}", url.PathEscape(parameterValueToString(r.fundingSourceToken, "fundingSourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFundingsourcesBusinessBusinesstokenRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	businessToken string
	type_ *string
	fields *string
}

// Type of funding source to return: ACH or payment card. Leave unspecified to return both types.
func (r ApiGetFundingsourcesBusinessBusinesstokenRequest) Type_(type_ string) ApiGetFundingsourcesBusinessBusinesstokenRequest {
	r.type_ = &type_
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetFundingsourcesBusinessBusinesstokenRequest) Fields(fields string) ApiGetFundingsourcesBusinessBusinesstokenRequest {
	r.fields = &fields
	return r
}

func (r ApiGetFundingsourcesBusinessBusinesstokenRequest) Execute() (*FundingAccountListResponse, *http.Response, error) {
	return r.ApiService.GetFundingsourcesBusinessBusinesstokenExecute(r)
}

/*
GetFundingsourcesBusinessBusinesstoken List sources for business

List funding sources associated with a specific business.

This endpoint supports <</core-api/field-filtering, field filtering>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessToken Unique identifier of the business account holder.  Send a `GET` request to `/businesses` to retrieve business tokens.
 @return ApiGetFundingsourcesBusinessBusinesstokenRequest
*/
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesBusinessBusinesstoken(ctx context.Context, businessToken string) ApiGetFundingsourcesBusinessBusinesstokenRequest {
	return ApiGetFundingsourcesBusinessBusinesstokenRequest{
		ApiService: a,
		ctx: ctx,
		businessToken: businessToken,
	}
}

// Execute executes the request
//  @return FundingAccountListResponse
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesBusinessBusinesstokenExecute(r ApiGetFundingsourcesBusinessBusinesstokenRequest) (*FundingAccountListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FundingAccountListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.GetFundingsourcesBusinessBusinesstoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/business/{business_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"business_token"+"}", url.PathEscape(parameterValueToString(r.businessToken, "businessToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFundingsourcesPaymentcardFundingsourcetokenRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	fundingSourceToken string
}

func (r ApiGetFundingsourcesPaymentcardFundingsourcetokenRequest) Execute() (*PaymentCardResponseModel, *http.Response, error) {
	return r.ApiService.GetFundingsourcesPaymentcardFundingsourcetokenExecute(r)
}

/*
GetFundingsourcesPaymentcardFundingsourcetoken Retrieve payment card source

Retrieve a specific payment card funding source.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fundingSourceToken U|- Unique identifier of the funding source. Send a `GET` request to `/fundingsources/user/{user_token}` to retrieve existing funding source tokens for a user or to `/fundingsources/business/{business_token}` to retrieve existing funding source tokens for a business.
 @return ApiGetFundingsourcesPaymentcardFundingsourcetokenRequest
*/
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesPaymentcardFundingsourcetoken(ctx context.Context, fundingSourceToken string) ApiGetFundingsourcesPaymentcardFundingsourcetokenRequest {
	return ApiGetFundingsourcesPaymentcardFundingsourcetokenRequest{
		ApiService: a,
		ctx: ctx,
		fundingSourceToken: fundingSourceToken,
	}
}

// Execute executes the request
//  @return PaymentCardResponseModel
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesPaymentcardFundingsourcetokenExecute(r ApiGetFundingsourcesPaymentcardFundingsourcetokenRequest) (*PaymentCardResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCardResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.GetFundingsourcesPaymentcardFundingsourcetoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/paymentcard/{funding_source_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"funding_source_token"+"}", url.PathEscape(parameterValueToString(r.fundingSourceToken, "fundingSourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFundingsourcesUserUsertokenRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	userToken string
	type_ *string
	fields *string
}

// Type of funding source to retrieve: ACH or payment card. Leave unspecified to return both types.
func (r ApiGetFundingsourcesUserUsertokenRequest) Type_(type_ string) ApiGetFundingsourcesUserUsertokenRequest {
	r.type_ = &type_
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetFundingsourcesUserUsertokenRequest) Fields(fields string) ApiGetFundingsourcesUserUsertokenRequest {
	r.fields = &fields
	return r
}

func (r ApiGetFundingsourcesUserUsertokenRequest) Execute() (*FundingAccountListResponse, *http.Response, error) {
	return r.ApiService.GetFundingsourcesUserUsertokenExecute(r)
}

/*
GetFundingsourcesUserUsertoken List sources for user

List funding sources associated with a specific user.

This endpoint supports <</core-api/field-filtering, field filtering>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userToken Unique identifier of the user account holder.
 @return ApiGetFundingsourcesUserUsertokenRequest
*/
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesUserUsertoken(ctx context.Context, userToken string) ApiGetFundingsourcesUserUsertokenRequest {
	return ApiGetFundingsourcesUserUsertokenRequest{
		ApiService: a,
		ctx: ctx,
		userToken: userToken,
	}
}

// Execute executes the request
//  @return FundingAccountListResponse
func (a *AccountHolderFundingSourcesAPIService) GetFundingsourcesUserUsertokenExecute(r ApiGetFundingsourcesUserUsertokenRequest) (*FundingAccountListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FundingAccountListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.GetFundingsourcesUserUsertoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/user/{user_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_token"+"}", url.PathEscape(parameterValueToString(r.userToken, "userToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFundingsourcesAchRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	achModel *AchModel
}

func (r ApiPostFundingsourcesAchRequest) AchModel(achModel AchModel) ApiPostFundingsourcesAchRequest {
	r.achModel = &achModel
	return r
}

func (r ApiPostFundingsourcesAchRequest) Execute() (*AchResponseModel, *http.Response, error) {
	return r.ApiService.PostFundingsourcesAchExecute(r)
}

/*
PostFundingsourcesAch Create ACH source

Create an ACH funding source for an existing account holder.
Specify the account holder of the funding source by passing a user or business token.

When adding an ACH funding source, a small amount is deposited in the bank account as a test.
The test deposit should be reflected in the account after two to three business days.
You must then make an API call to verify the deposit amount in order to activate the ACH account.
See <</core-api/account-holder-funding-sources#putFundingsourcesAchFundingsourcetoken, Verify or Update ACH Funding Source>> on this page for more information.

The response body returns details about the account, including the verification status.
Possible ACH verification status values include `VERIFICATION_PENDING`, `ACH_VERIFIED`, and `ACH_FAILED`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFundingsourcesAchRequest
*/
func (a *AccountHolderFundingSourcesAPIService) PostFundingsourcesAch(ctx context.Context) ApiPostFundingsourcesAchRequest {
	return ApiPostFundingsourcesAchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchResponseModel
func (a *AccountHolderFundingSourcesAPIService) PostFundingsourcesAchExecute(r ApiPostFundingsourcesAchRequest) (*AchResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.PostFundingsourcesAch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/ach"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.achModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFundingsourcesAchPartnerRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	achPartnerRequestModel *AchPartnerRequestModel
}

func (r ApiPostFundingsourcesAchPartnerRequest) AchPartnerRequestModel(achPartnerRequestModel AchPartnerRequestModel) ApiPostFundingsourcesAchPartnerRequest {
	r.achPartnerRequestModel = &achPartnerRequestModel
	return r
}

func (r ApiPostFundingsourcesAchPartnerRequest) Execute() (*AchResponseModel, *http.Response, error) {
	return r.ApiService.PostFundingsourcesAchPartnerExecute(r)
}

/*
PostFundingsourcesAchPartner Create ACH source via a partner integration

Create an ACH funding source for an existing account holder by using a third-party partner to handle account validation and provide PII account data.
Because you don't handle any personally identifiable information (PII) yourself, using a third party when creating the funding source enables you to bypass the regulatory and compliance measures related to capturing, storing, and transmitting PII.

With this endpoint, you can create a US-based funding source—either a checking account or a savings account—for a program or user without passing bank account details such as the account number or routing number to Marqeta.
Instead, validating account data and account verification is handled by the third-party partner you specify, and a secure token (i.e., a Plaid `processor_token`) is shared across partners.
By using a secure account verification platform to provide immediate verification, you shorten the wait time until the ACH funding source is ready and avoid managing the microdeposit-based account verification process.

To create an ACH funding source for an existing account holder without validating through a third party, see <</core-api/account-holder-funding-sources#postFundingsourcesAch, Create ACH source>>.

[NOTE]
This endpoint assumes that you already have established a relationship with both Marqeta and the third-party account validation partner you want to use.
In addition, you must explicitly authorize the sharing of information with the third-party partner, and enable Marqeta as a processor for your integration.
For more information, contact your Marqeta representative.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFundingsourcesAchPartnerRequest
*/
func (a *AccountHolderFundingSourcesAPIService) PostFundingsourcesAchPartner(ctx context.Context) ApiPostFundingsourcesAchPartnerRequest {
	return ApiPostFundingsourcesAchPartnerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AchResponseModel
func (a *AccountHolderFundingSourcesAPIService) PostFundingsourcesAchPartnerExecute(r ApiPostFundingsourcesAchPartnerRequest) (*AchResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.PostFundingsourcesAchPartner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/ach/partner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.achPartnerRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFundingsourcesPaymentcardRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	tokenRequest *TokenRequest
}

func (r ApiPostFundingsourcesPaymentcardRequest) TokenRequest(tokenRequest TokenRequest) ApiPostFundingsourcesPaymentcardRequest {
	r.tokenRequest = &tokenRequest
	return r
}

func (r ApiPostFundingsourcesPaymentcardRequest) Execute() (*PaymentCardResponseModel, *http.Response, error) {
	return r.ApiService.PostFundingsourcesPaymentcardExecute(r)
}

/*
PostFundingsourcesPaymentcard Create payment card source

Create a payment card funding source for an existing account holder.
This endpoint returns the card type and the last four digits of the card, and then sets the `active_ field` to `true`.

Marqeta retains only a tokenized representation of the card number.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFundingsourcesPaymentcardRequest
*/
func (a *AccountHolderFundingSourcesAPIService) PostFundingsourcesPaymentcard(ctx context.Context) ApiPostFundingsourcesPaymentcardRequest {
	return ApiPostFundingsourcesPaymentcardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentCardResponseModel
func (a *AccountHolderFundingSourcesAPIService) PostFundingsourcesPaymentcardExecute(r ApiPostFundingsourcesPaymentcardRequest) (*PaymentCardResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCardResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.PostFundingsourcesPaymentcard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/paymentcard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFundingsourcesAchFundingsourcetokenRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	fundingSourceToken string
	achVerificationModel *AchVerificationModel
}

func (r ApiPutFundingsourcesAchFundingsourcetokenRequest) AchVerificationModel(achVerificationModel AchVerificationModel) ApiPutFundingsourcesAchFundingsourcetokenRequest {
	r.achVerificationModel = &achVerificationModel
	return r
}

func (r ApiPutFundingsourcesAchFundingsourcetokenRequest) Execute() (*AchResponseModel, *http.Response, error) {
	return r.ApiService.PutFundingsourcesAchFundingsourcetokenExecute(r)
}

/*
PutFundingsourcesAchFundingsourcetoken Verify or update ACH source

Verify or update an ACH funding source.

If you are verifying the ACH source, include the verification amounts in the body of the request.
ACH verification will fail if the verification amounts are not entered in the correct order.
`verify_amount1` must match the first deposit amount, and `verify_amount2` must match the second.

If you are updating the ACH source, include the `active` field instead.
The `active` field is the only field you can update.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fundingSourceToken Unique identifier of the funding source.  Send a `GET` request to `/fundingsources/user/{user_token}` to retrieve existing funding source tokens for a user or to `/fundingsources/business/{business_token}` to retrieve existing funding source tokens for a business.
 @return ApiPutFundingsourcesAchFundingsourcetokenRequest
*/
func (a *AccountHolderFundingSourcesAPIService) PutFundingsourcesAchFundingsourcetoken(ctx context.Context, fundingSourceToken string) ApiPutFundingsourcesAchFundingsourcetokenRequest {
	return ApiPutFundingsourcesAchFundingsourcetokenRequest{
		ApiService: a,
		ctx: ctx,
		fundingSourceToken: fundingSourceToken,
	}
}

// Execute executes the request
//  @return AchResponseModel
func (a *AccountHolderFundingSourcesAPIService) PutFundingsourcesAchFundingsourcetokenExecute(r ApiPutFundingsourcesAchFundingsourcetokenRequest) (*AchResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AchResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.PutFundingsourcesAchFundingsourcetoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/ach/{funding_source_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"funding_source_token"+"}", url.PathEscape(parameterValueToString(r.fundingSourceToken, "fundingSourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.achVerificationModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFundingsourcesFundingsourcetokenRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	fundingSourceToken string
	tokenUpdateRequest *TokenUpdateRequest
}

// Payment card
func (r ApiPutFundingsourcesFundingsourcetokenRequest) TokenUpdateRequest(tokenUpdateRequest TokenUpdateRequest) ApiPutFundingsourcesFundingsourcetokenRequest {
	r.tokenUpdateRequest = &tokenUpdateRequest
	return r
}

func (r ApiPutFundingsourcesFundingsourcetokenRequest) Execute() (*PaymentCardResponseModel, *http.Response, error) {
	return r.ApiService.PutFundingsourcesFundingsourcetokenExecute(r)
}

/*
PutFundingsourcesFundingsourcetoken Update payment card source

Update a payment card funding source.
Only the values of parameters specified in the request are modified; all others are left unchanged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fundingSourceToken Unique identifier of the funding source.  Send a `GET` request to `/fundingsources/user/{user_token}` to retrieve existing funding source tokens for a user or to `/fundingsources/business/{business_token}` to retrieve existing funding source tokens for a business.
 @return ApiPutFundingsourcesFundingsourcetokenRequest
*/
func (a *AccountHolderFundingSourcesAPIService) PutFundingsourcesFundingsourcetoken(ctx context.Context, fundingSourceToken string) ApiPutFundingsourcesFundingsourcetokenRequest {
	return ApiPutFundingsourcesFundingsourcetokenRequest{
		ApiService: a,
		ctx: ctx,
		fundingSourceToken: fundingSourceToken,
	}
}

// Execute executes the request
//  @return PaymentCardResponseModel
func (a *AccountHolderFundingSourcesAPIService) PutFundingsourcesFundingsourcetokenExecute(r ApiPutFundingsourcesFundingsourcetokenRequest) (*PaymentCardResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCardResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.PutFundingsourcesFundingsourcetoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/paymentcard/{funding_source_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"funding_source_token"+"}", url.PathEscape(parameterValueToString(r.fundingSourceToken, "fundingSourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("tokenUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFundingsourcesFundingsourcetokenDefaultRequest struct {
	ctx context.Context
	ApiService *AccountHolderFundingSourcesAPIService
	fundingSourceToken string
}

func (r ApiPutFundingsourcesFundingsourcetokenDefaultRequest) Execute() (*PaymentCardResponseModel, *http.Response, error) {
	return r.ApiService.PutFundingsourcesFundingsourcetokenDefaultExecute(r)
}

/*
PutFundingsourcesFundingsourcetokenDefault Set default source

Configure either an ACH funding source or a payment card funding source as the default funding source.

A default funding source is used when you omit the `funding_source_token` field from funding requests, such as a `POST` request to `/gpaorders`.
Note that the first funding source you create is automatically set as the default (`is_default_source=true`).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fundingSourceToken Unique identifier of the funding source.  Send a `GET` request to `/fundingsources/user/{user_token}` to retrieve existing funding source tokens for a user or to `/fundingsources/business/{business_token}` to retrieve existing funding source tokens for a business.
 @return ApiPutFundingsourcesFundingsourcetokenDefaultRequest
*/
func (a *AccountHolderFundingSourcesAPIService) PutFundingsourcesFundingsourcetokenDefault(ctx context.Context, fundingSourceToken string) ApiPutFundingsourcesFundingsourcetokenDefaultRequest {
	return ApiPutFundingsourcesFundingsourcetokenDefaultRequest{
		ApiService: a,
		ctx: ctx,
		fundingSourceToken: fundingSourceToken,
	}
}

// Execute executes the request
//  @return PaymentCardResponseModel
func (a *AccountHolderFundingSourcesAPIService) PutFundingsourcesFundingsourcetokenDefaultExecute(r ApiPutFundingsourcesFundingsourcetokenDefaultRequest) (*PaymentCardResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCardResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountHolderFundingSourcesAPIService.PutFundingsourcesFundingsourcetokenDefault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fundingsources/{funding_source_token}/default"
	localVarPath = strings.Replace(localVarPath, "{"+"funding_source_token"+"}", url.PathEscape(parameterValueToString(r.fundingSourceToken, "fundingSourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
