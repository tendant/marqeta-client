/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DelinquencyAPIService DelinquencyAPI service
type DelinquencyAPIService service

type ApiResendWebhookEventRequest struct {
	ctx context.Context
	ApiService *DelinquencyAPIService
	eventType string
	resourceToken string
}

func (r ApiResendWebhookEventRequest) Execute() (*WebhookEventResendContainerResponse, *http.Response, error) {
	return r.ApiService.ResendWebhookEventExecute(r)
}

/*
ResendWebhookEvent Resend credit event notification

Resends a credit event notification to your webhook endpoint.

Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty.
The event notification is resent to your webhook endpoint and also returned in the response to this request.

For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>.
For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventType Specifies the type of event you want to resend.
 @param resourceToken The unique identifier of the resource for which you want to resend a notification.  Send a `GET` request to `/credit/accounts/{account_token}/journalentries` to retrieve existing journal entry tokens.  Send a `GET` request to `/credit/accounts/{account_token}/ledgerentries` to retrieve existing ledger entry tokens.  Send a `GET` request to `/accounts/{account_token}/accounttransitions` to retrieve existing account transition tokens.  Send a `GET` request to `/credit/accounts/{account_token}/payments/{payment_token}` to retrieve existing payment transition tokens.  Send a `GET` request to `/accounts/{account_token}/statements` to retrieve existing statement summary tokens.  Send a `GET` request to `/accounts/{account_token}/delinquencystate/transitions` to retrieve existing delinquency state transition tokens.
 @return ApiResendWebhookEventRequest
*/
func (a *DelinquencyAPIService) ResendWebhookEvent(ctx context.Context, eventType string, resourceToken string) ApiResendWebhookEventRequest {
	return ApiResendWebhookEventRequest{
		ApiService: a,
		ctx: ctx,
		eventType: eventType,
		resourceToken: resourceToken,
	}
}

// Execute executes the request
//  @return WebhookEventResendContainerResponse
func (a *DelinquencyAPIService) ResendWebhookEventExecute(r ApiResendWebhookEventRequest) (*WebhookEventResendContainerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookEventResendContainerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquencyAPIService.ResendWebhookEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/webhooks/{event_type}/{resource_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"event_type"+"}", url.PathEscape(parameterValueToString(r.eventType, "eventType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_token"+"}", url.PathEscape(parameterValueToString(r.resourceToken, "resourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveDelinquencyStateRequest struct {
	ctx context.Context
	ApiService *DelinquencyAPIService
	accountToken string
}

func (r ApiRetrieveDelinquencyStateRequest) Execute() (*DelinquencyStateResponse, *http.Response, error) {
	return r.ApiService.RetrieveDelinquencyStateExecute(r)
}

/*
RetrieveDelinquencyState Retrieve delinquency state

Retrieve details of the current delinquency state of a credit account.

An account is delinquent when it is past due on payments and current when it is up to date on payments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @return ApiRetrieveDelinquencyStateRequest
*/
func (a *DelinquencyAPIService) RetrieveDelinquencyState(ctx context.Context, accountToken string) ApiRetrieveDelinquencyStateRequest {
	return ApiRetrieveDelinquencyStateRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
	}
}

// Execute executes the request
//  @return DelinquencyStateResponse
func (a *DelinquencyAPIService) RetrieveDelinquencyStateExecute(r ApiRetrieveDelinquencyStateRequest) (*DelinquencyStateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DelinquencyStateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquencyAPIService.RetrieveDelinquencyState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/delinquencystate"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveDelinquencyTransitionRequest struct {
	ctx context.Context
	ApiService *DelinquencyAPIService
	accountToken string
	delinquencyTransitionToken string
}

func (r ApiRetrieveDelinquencyTransitionRequest) Execute() (*DelinquencyTransitionResponse, *http.Response, error) {
	return r.ApiService.RetrieveDelinquencyTransitionExecute(r)
}

/*
RetrieveDelinquencyTransition Retrieve delinquency state transition

Retrieve a specific delinquency state transition on a credit account.

A delinquency state transition occurs when an account's delinquency state transitions between delinquent and current.
An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken Unique identifier of the credit account whose delinquency state transition you want to retrieve.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param delinquencyTransitionToken Unique identifier of the delinquency state transition.
 @return ApiRetrieveDelinquencyTransitionRequest
*/
func (a *DelinquencyAPIService) RetrieveDelinquencyTransition(ctx context.Context, accountToken string, delinquencyTransitionToken string) ApiRetrieveDelinquencyTransitionRequest {
	return ApiRetrieveDelinquencyTransitionRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		delinquencyTransitionToken: delinquencyTransitionToken,
	}
}

// Execute executes the request
//  @return DelinquencyTransitionResponse
func (a *DelinquencyAPIService) RetrieveDelinquencyTransitionExecute(r ApiRetrieveDelinquencyTransitionRequest) (*DelinquencyTransitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DelinquencyTransitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquencyAPIService.RetrieveDelinquencyTransition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/delinquencystate/transitions/{delinquency_transition_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"delinquency_transition_token"+"}", url.PathEscape(parameterValueToString(r.delinquencyTransitionToken, "delinquencyTransitionToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveDelinquencyTransitionsRequest struct {
	ctx context.Context
	ApiService *DelinquencyAPIService
	accountToken string
	count *int32
	startIndex *int32
	sortBy *string
}

// The number of resources to retrieve.
func (r ApiRetrieveDelinquencyTransitionsRequest) Count(count int32) ApiRetrieveDelinquencyTransitionsRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiRetrieveDelinquencyTransitionsRequest) StartIndex(startIndex int32) ApiRetrieveDelinquencyTransitionsRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;impactTime&#x60;, and not by the field names appearing in response bodies such as &#x60;impact_time&#x60;.
func (r ApiRetrieveDelinquencyTransitionsRequest) SortBy(sortBy string) ApiRetrieveDelinquencyTransitionsRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiRetrieveDelinquencyTransitionsRequest) Execute() (*DelinquencyTransitionsResponsePage, *http.Response, error) {
	return r.ApiService.RetrieveDelinquencyTransitionsExecute(r)
}

/*
RetrieveDelinquencyTransitions List delinquency state transitions

Retrieve an array of delinquency state transitions for a credit account.

A delinquency state transition occurs when an account's delinquency state transitions between delinquent and current.
An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken Unique identifier of the credit account whose delinquency state transitions you want to retrieve.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @return ApiRetrieveDelinquencyTransitionsRequest
*/
func (a *DelinquencyAPIService) RetrieveDelinquencyTransitions(ctx context.Context, accountToken string) ApiRetrieveDelinquencyTransitionsRequest {
	return ApiRetrieveDelinquencyTransitionsRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
	}
}

// Execute executes the request
//  @return DelinquencyTransitionsResponsePage
func (a *DelinquencyAPIService) RetrieveDelinquencyTransitionsExecute(r ApiRetrieveDelinquencyTransitionsRequest) (*DelinquencyTransitionsResponsePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DelinquencyTransitionsResponsePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquencyAPIService.RetrieveDelinquencyTransitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/delinquencystate/transitions"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-impactTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
