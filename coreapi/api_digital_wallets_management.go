/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package coreapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DigitalWalletsManagementAPIService DigitalWalletsManagementAPI service
type DigitalWalletsManagementAPIService service

type ApiGenerateApplePayWPPJWTRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	reqSysId *string
	requestForApplePayWppJWT *RequestForApplePayWppJWT
}

// Random pseudo-unique value used for troubleshooting between multiple parties.
func (r ApiGenerateApplePayWPPJWTRequest) ReqSysId(reqSysId string) ApiGenerateApplePayWPPJWTRequest {
	r.reqSysId = &reqSysId
	return r
}

func (r ApiGenerateApplePayWPPJWTRequest) RequestForApplePayWppJWT(requestForApplePayWppJWT RequestForApplePayWppJWT) ApiGenerateApplePayWPPJWTRequest {
	r.requestForApplePayWppJWT = &requestForApplePayWppJWT
	return r
}

func (r ApiGenerateApplePayWPPJWTRequest) Execute() (*WebPushProvisioningApplePayJWTResponse, *http.Response, error) {
	return r.ApiService.GenerateApplePayWPPJWTExecute(r)
}

/*
GenerateApplePayWPPJWT Create request for Apple Wallet web push provisioning

[NOTE]
This endpoint is currently in beta and subject to change.
For more information, contact your Marqeta representative.

Use this endpoint to add a card to Apple Wallet via a web application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateApplePayWPPJWTRequest
*/
func (a *DigitalWalletsManagementAPIService) GenerateApplePayWPPJWT(ctx context.Context) ApiGenerateApplePayWPPJWTRequest {
	return ApiGenerateApplePayWPPJWTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebPushProvisioningApplePayJWTResponse
func (a *DigitalWalletsManagementAPIService) GenerateApplePayWPPJWTExecute(r ApiGenerateApplePayWPPJWTRequest) (*WebPushProvisioningApplePayJWTResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebPushProvisioningApplePayJWTResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GenerateApplePayWPPJWT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallets/wpp/applePayJWT"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reqSysId == nil {
		return localVarReturnValue, nil, reportError("reqSysId is required and must be specified")
	}
	if r.requestForApplePayWppJWT == nil {
		return localVarReturnValue, nil, reportError("requestForApplePayWppJWT is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "req-sys-id", r.reqSysId, "")
	// body params
	localVarPostBody = r.requestForApplePayWppJWT
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDigitalwallettokensRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
	startDate *string
	endDate *string
	panReferenceId *string
	tokenReferenceId *string
	correlationId *string
	tokenType *string
	tokenRequestorName *string
	state *string
	embed *string
}

// Number of digital wallet token resources to retrieve.
func (r ApiGetDigitalwallettokensRequest) Count(count int32) ApiGetDigitalwallettokensRequest {
	r.count = &count
	return r
}

// Sort order index of the first digital wallet token resource in the returned array.
func (r ApiGetDigitalwallettokensRequest) StartIndex(startIndex int32) ApiGetDigitalwallettokensRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetDigitalwallettokensRequest) Fields(fields string) ApiGetDigitalwallettokensRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetDigitalwallettokensRequest) SortBy(sortBy string) ApiGetDigitalwallettokensRequest {
	r.sortBy = &sortBy
	return r
}

// Date when the digital wallet token becomes active.
func (r ApiGetDigitalwallettokensRequest) StartDate(startDate string) ApiGetDigitalwallettokensRequest {
	r.startDate = &startDate
	return r
}

// Expiration date of the digital wallet token.
func (r ApiGetDigitalwallettokensRequest) EndDate(endDate string) ApiGetDigitalwallettokensRequest {
	r.endDate = &endDate
	return r
}

// Unique identifier of the digital wallet token primary account number (PAN) within the card network. This value may vary, depending on the digital wallet. For example, the &#x60;pan_reference_id&#x60; may be different in Apple Wallet and Google Wallet for the same digital wallet token.
func (r ApiGetDigitalwallettokensRequest) PanReferenceId(panReferenceId string) ApiGetDigitalwallettokensRequest {
	r.panReferenceId = &panReferenceId
	return r
}

// Unique identifier of the digital wallet token within the card network. The &#x60;token_reference_id&#x60; is unique at the card network level.
func (r ApiGetDigitalwallettokensRequest) TokenReferenceId(tokenReferenceId string) ApiGetDigitalwallettokensRequest {
	r.tokenReferenceId = &tokenReferenceId
	return r
}

// Unique value representing a tokenization request (Mastercard only).
func (r ApiGetDigitalwallettokensRequest) CorrelationId(correlationId string) ApiGetDigitalwallettokensRequest {
	r.correlationId = &correlationId
	return r
}

// Comma-delimited list of digital wallet token types to display.
func (r ApiGetDigitalwallettokensRequest) TokenType(tokenType string) ApiGetDigitalwallettokensRequest {
	r.tokenType = &tokenType
	return r
}

// Name of the token requestor within the card network.  *NOTE:* The list of example values for this field is maintained by the card networks and is subject to change.
func (r ApiGetDigitalwallettokensRequest) TokenRequestorName(tokenRequestorName string) ApiGetDigitalwallettokensRequest {
	r.tokenRequestorName = &tokenRequestorName
	return r
}

// Comma-delimited list of digital wallet token states to display.
func (r ApiGetDigitalwallettokensRequest) State(state string) ApiGetDigitalwallettokensRequest {
	r.state = &state
	return r
}

// An optional embedded user object.
func (r ApiGetDigitalwallettokensRequest) Embed(embed string) ApiGetDigitalwallettokensRequest {
	r.embed = &embed
	return r
}

func (r ApiGetDigitalwallettokensRequest) Execute() (*DigitalWalletTokenListResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensExecute(r)
}

/*
GetDigitalwallettokens List digital wallet tokens

Use this endpoint to retrieve a list of digital wallet tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDigitalwallettokensRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokens(ctx context.Context) ApiGetDigitalwallettokensRequest {
	return ApiGetDigitalwallettokensRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenListResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensExecute(r ApiGetDigitalwallettokensRequest) (*DigitalWalletTokenListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.panReferenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pan_reference_id", r.panReferenceId, "")
	}
	if r.tokenReferenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_reference_id", r.tokenReferenceId, "")
	}
	if r.correlationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "correlation_id", r.correlationId, "")
	}
	if r.tokenType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_type", r.tokenType, "")
	}
	if r.tokenRequestorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token_requestor_name", r.tokenRequestorName, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.embed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed", r.embed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDigitalwallettokensCardCardtokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	cardToken string
	count *int32
	startIndex *int32
	sortBy *string
}

// Number of digital wallet token resources to retrieve.
func (r ApiGetDigitalwallettokensCardCardtokenRequest) Count(count int32) ApiGetDigitalwallettokensCardCardtokenRequest {
	r.count = &count
	return r
}

// Sort order index of the first digital wallet token resource in the returned array.
func (r ApiGetDigitalwallettokensCardCardtokenRequest) StartIndex(startIndex int32) ApiGetDigitalwallettokensCardCardtokenRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetDigitalwallettokensCardCardtokenRequest) SortBy(sortBy string) ApiGetDigitalwallettokensCardCardtokenRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetDigitalwallettokensCardCardtokenRequest) Execute() (*DigitalWalletTokenListResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensCardCardtokenExecute(r)
}

/*
GetDigitalwallettokensCardCardtoken List digital wallet tokens for card

Use this endpoint to return an array of all digital wallet tokens for a particular card.

This endpoint supports <</core-api/sorting-and-pagination, pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cardToken Unique identifier of the card. Used to minimize the need to exchange card details during subsequent calls, and also for troubleshooting.
 @return ApiGetDigitalwallettokensCardCardtokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensCardCardtoken(ctx context.Context, cardToken string) ApiGetDigitalwallettokensCardCardtokenRequest {
	return ApiGetDigitalwallettokensCardCardtokenRequest{
		ApiService: a,
		ctx: ctx,
		cardToken: cardToken,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenListResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensCardCardtokenExecute(r ApiGetDigitalwallettokensCardCardtokenRequest) (*DigitalWalletTokenListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokensCardCardtoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens/card/{card_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"card_token"+"}", url.PathEscape(parameterValueToString(r.cardToken, "cardToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDigitalwallettokensTokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
}

func (r ApiGetDigitalwallettokensTokenRequest) Execute() (*DigitalWalletToken, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensTokenExecute(r)
}

/*
GetDigitalwallettokensToken Retrieve digital wallet token

Use this endpoint to retrieve a specific digital wallet token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT).
 @return ApiGetDigitalwallettokensTokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensToken(ctx context.Context, token string) ApiGetDigitalwallettokensTokenRequest {
	return ApiGetDigitalwallettokensTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletToken
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensTokenExecute(r ApiGetDigitalwallettokensTokenRequest) (*DigitalWalletToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokensToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDigitalwallettokensTokenShowtokenpanRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
}

func (r ApiGetDigitalwallettokensTokenShowtokenpanRequest) Execute() (*DigitalWalletToken, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokensTokenShowtokenpanExecute(r)
}

/*
GetDigitalwallettokensTokenShowtokenpan Retrieve digital wallet token PAN

Use this endpoint to retrieve a digital wallet token with the entire primary account number (PAN) displayed.
The PAN returned is of the digital wallet token and not of the card.
(For security reasons, the PAN is not fully visible on the digital wallet token returned by `GET` `/digitalwallettokens/{token}`.)

[WARNING]
Sending a request to this endpoint requires PCI DSS compliance.
You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder's primary account number (PAN), personal identification number (PIN), and card expiration date.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT).
 @return ApiGetDigitalwallettokensTokenShowtokenpanRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensTokenShowtokenpan(ctx context.Context, token string) ApiGetDigitalwallettokensTokenShowtokenpanRequest {
	return ApiGetDigitalwallettokensTokenShowtokenpanRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletToken
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokensTokenShowtokenpanExecute(r ApiGetDigitalwallettokensTokenShowtokenpanRequest) (*DigitalWalletToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokensTokenShowtokenpan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokens/{token}/showtokenpan"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
}

// Number of digital wallet transitions to retrieve.
func (r ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) Count(count int32) ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.count = &count
	return r
}

// The sort order index of the first digital wallet token in the returned array.
func (r ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) StartIndex(startIndex int32) ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) Fields(fields string) ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) SortBy(sortBy string) ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) Execute() (*DigitalWalletTokenTransitionListResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokentransitionsDigitalwallettokenTokenExecute(r)
}

/*
GetDigitalwallettokentransitionsDigitalwallettokenToken List transitions for digital wallet token

Use this endpoint to return an array of all transitions for a particular digital wallet token.

This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT).
 @return ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsDigitalwallettokenToken(ctx context.Context, token string) ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest {
	return ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenTransitionListResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsDigitalwallettokenTokenExecute(r ApiGetDigitalwallettokentransitionsDigitalwallettokenTokenRequest) (*DigitalWalletTokenTransitionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenTransitionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokentransitionsDigitalwallettokenToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokentransitions/digitalwallettoken/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-id"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDigitalwallettokentransitionsTokenRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	token string
	fields *string
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetDigitalwallettokentransitionsTokenRequest) Fields(fields string) ApiGetDigitalwallettokentransitionsTokenRequest {
	r.fields = &fields
	return r
}

func (r ApiGetDigitalwallettokentransitionsTokenRequest) Execute() (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	return r.ApiService.GetDigitalwallettokentransitionsTokenExecute(r)
}

/*
GetDigitalwallettokentransitionsToken Retrieve digital wallet token transition

Use this endpoint to retrieve a specific digital wallet token transition.

This endpoint supports <</core-api/field-filtering, field filtering>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the digital wallet token (DWT) transition.
 @return ApiGetDigitalwallettokentransitionsTokenRequest
*/
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsToken(ctx context.Context, token string) ApiGetDigitalwallettokentransitionsTokenRequest {
	return ApiGetDigitalwallettokentransitionsTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenTransitionResponse
func (a *DigitalWalletsManagementAPIService) GetDigitalwallettokentransitionsTokenExecute(r ApiGetDigitalwallettokentransitionsTokenRequest) (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenTransitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.GetDigitalwallettokentransitionsToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokentransitions/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDigitalwalletprovisionrequestsAndroidpayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletAndroidPayProvisionRequest *DigitalWalletAndroidPayProvisionRequest
}

func (r ApiPostDigitalwalletprovisionrequestsAndroidpayRequest) DigitalWalletAndroidPayProvisionRequest(digitalWalletAndroidPayProvisionRequest DigitalWalletAndroidPayProvisionRequest) ApiPostDigitalwalletprovisionrequestsAndroidpayRequest {
	r.digitalWalletAndroidPayProvisionRequest = &digitalWalletAndroidPayProvisionRequest
	return r
}

func (r ApiPostDigitalwalletprovisionrequestsAndroidpayRequest) Execute() (*DigitalWalletAndroidPayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsAndroidpayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsAndroidpay Create digital wallet token provisioning request for Google Wallet

Use this endpoint to return card data for use in provisioning a digital wallet token into Google Wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDigitalwalletprovisionrequestsAndroidpayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsAndroidpay(ctx context.Context) ApiPostDigitalwalletprovisionrequestsAndroidpayRequest {
	return ApiPostDigitalwalletprovisionrequestsAndroidpayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletAndroidPayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsAndroidpayExecute(r ApiPostDigitalwalletprovisionrequestsAndroidpayRequest) (*DigitalWalletAndroidPayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletAndroidPayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsAndroidpay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/androidpay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletAndroidPayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDigitalwalletprovisionrequestsApplepayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletApplePayProvisionRequest *DigitalWalletApplePayProvisionRequest
}

func (r ApiPostDigitalwalletprovisionrequestsApplepayRequest) DigitalWalletApplePayProvisionRequest(digitalWalletApplePayProvisionRequest DigitalWalletApplePayProvisionRequest) ApiPostDigitalwalletprovisionrequestsApplepayRequest {
	r.digitalWalletApplePayProvisionRequest = &digitalWalletApplePayProvisionRequest
	return r
}

func (r ApiPostDigitalwalletprovisionrequestsApplepayRequest) Execute() (*DigitalWalletApplePayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsApplepayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsApplepay Create digital wallet token provisioning request for Apple Wallet

Use this endpoint to return card data for use in provisioning a digital wallet token into Apple Wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDigitalwalletprovisionrequestsApplepayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsApplepay(ctx context.Context) ApiPostDigitalwalletprovisionrequestsApplepayRequest {
	return ApiPostDigitalwalletprovisionrequestsApplepayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletApplePayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsApplepayExecute(r ApiPostDigitalwalletprovisionrequestsApplepayRequest) (*DigitalWalletApplePayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletApplePayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsApplepay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/applepay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletApplePayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDigitalwalletprovisionrequestsSamsungpayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletSamsungPayProvisionRequest *DigitalWalletSamsungPayProvisionRequest
}

func (r ApiPostDigitalwalletprovisionrequestsSamsungpayRequest) DigitalWalletSamsungPayProvisionRequest(digitalWalletSamsungPayProvisionRequest DigitalWalletSamsungPayProvisionRequest) ApiPostDigitalwalletprovisionrequestsSamsungpayRequest {
	r.digitalWalletSamsungPayProvisionRequest = &digitalWalletSamsungPayProvisionRequest
	return r
}

func (r ApiPostDigitalwalletprovisionrequestsSamsungpayRequest) Execute() (*DigitalWalletSamsungPayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsSamsungpayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsSamsungpay Create digital wallet token provisioning request for Samsung Wallet

[NOTE]
This endpoint is limited in availability.
For more information, contact your Marqeta representative.

Use this endpoint to return card data for use in provisioning a digital wallet token into Samsung Wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDigitalwalletprovisionrequestsSamsungpayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsSamsungpay(ctx context.Context) ApiPostDigitalwalletprovisionrequestsSamsungpayRequest {
	return ApiPostDigitalwalletprovisionrequestsSamsungpayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletSamsungPayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsSamsungpayExecute(r ApiPostDigitalwalletprovisionrequestsSamsungpayRequest) (*DigitalWalletSamsungPayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletSamsungPayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsSamsungpay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/samsungpay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletSamsungPayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDigitalwalletprovisionrequestsXPayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletXPayProvisionRequest *DigitalWalletXPayProvisionRequest
}

func (r ApiPostDigitalwalletprovisionrequestsXPayRequest) DigitalWalletXPayProvisionRequest(digitalWalletXPayProvisionRequest DigitalWalletXPayProvisionRequest) ApiPostDigitalwalletprovisionrequestsXPayRequest {
	r.digitalWalletXPayProvisionRequest = &digitalWalletXPayProvisionRequest
	return r
}

func (r ApiPostDigitalwalletprovisionrequestsXPayRequest) Execute() (*DigitalWalletXPayProvisionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwalletprovisionrequestsXPayExecute(r)
}

/*
PostDigitalwalletprovisionrequestsXPay Create digital wallet token provisioning request for XPay

[NOTE]
This endpoint is limited in availability.
For more information, contact your Marqeta representative.

Use this endpoint to return card data for use in provisioning a digital wallet token into an XPay digital wallet.

The returned card data is encrypted using the digital wallet provider's encryption key, thereby reducing your PCI compliance overhead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDigitalwalletprovisionrequestsXPayRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsXPay(ctx context.Context) ApiPostDigitalwalletprovisionrequestsXPayRequest {
	return ApiPostDigitalwalletprovisionrequestsXPayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletXPayProvisionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwalletprovisionrequestsXPayExecute(r ApiPostDigitalwalletprovisionrequestsXPayRequest) (*DigitalWalletXPayProvisionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletXPayProvisionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwalletprovisionrequestsXPay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwalletprovisionrequests/xpay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletXPayProvisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDigitalwallettokentransitionsRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	digitalWalletTokenTransitionRequest *DigitalWalletTokenTransitionRequest
}

func (r ApiPostDigitalwallettokentransitionsRequest) DigitalWalletTokenTransitionRequest(digitalWalletTokenTransitionRequest DigitalWalletTokenTransitionRequest) ApiPostDigitalwallettokentransitionsRequest {
	r.digitalWalletTokenTransitionRequest = &digitalWalletTokenTransitionRequest
	return r
}

func (r ApiPostDigitalwallettokentransitionsRequest) Execute() (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	return r.ApiService.PostDigitalwallettokentransitionsExecute(r)
}

/*
PostDigitalwallettokentransitions Create digital wallet token transition

Use this endpoint to transition a digital wallet token from one state to another.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDigitalwallettokentransitionsRequest
*/
func (a *DigitalWalletsManagementAPIService) PostDigitalwallettokentransitions(ctx context.Context) ApiPostDigitalwallettokentransitionsRequest {
	return ApiPostDigitalwallettokentransitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DigitalWalletTokenTransitionResponse
func (a *DigitalWalletsManagementAPIService) PostDigitalwallettokentransitionsExecute(r ApiPostDigitalwallettokentransitionsRequest) (*DigitalWalletTokenTransitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DigitalWalletTokenTransitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.PostDigitalwallettokentransitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallettokentransitions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.digitalWalletTokenTransitionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendOPCDataToGooglePayRequest struct {
	ctx context.Context
	ApiService *DigitalWalletsManagementAPIService
	reqSysId *string
	sendingProvisioningDataToGooglePayBackendRequest *SendingProvisioningDataToGooglePayBackendRequest
}

// Random pseudo-unique value used for troubleshooting between multiple parties.
func (r ApiSendOPCDataToGooglePayRequest) ReqSysId(reqSysId string) ApiSendOPCDataToGooglePayRequest {
	r.reqSysId = &reqSysId
	return r
}

func (r ApiSendOPCDataToGooglePayRequest) SendingProvisioningDataToGooglePayBackendRequest(sendingProvisioningDataToGooglePayBackendRequest SendingProvisioningDataToGooglePayBackendRequest) ApiSendOPCDataToGooglePayRequest {
	r.sendingProvisioningDataToGooglePayBackendRequest = &sendingProvisioningDataToGooglePayBackendRequest
	return r
}

func (r ApiSendOPCDataToGooglePayRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendOPCDataToGooglePayExecute(r)
}

/*
SendOPCDataToGooglePay Create request for Google Wallet web push provisioning

[NOTE]
This endpoint is currently in beta and subject to change.
For more information, contact your Marqeta representative.

Use this endpoint to add a card to Google Wallet via a web application.

This endpoint does not return a payload in response to a request.
Instead, a successful call will return a response code only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendOPCDataToGooglePayRequest
*/
func (a *DigitalWalletsManagementAPIService) SendOPCDataToGooglePay(ctx context.Context) ApiSendOPCDataToGooglePayRequest {
	return ApiSendOPCDataToGooglePayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DigitalWalletsManagementAPIService) SendOPCDataToGooglePayExecute(r ApiSendOPCDataToGooglePayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DigitalWalletsManagementAPIService.SendOPCDataToGooglePay")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/digitalwallets/wpp/googlePayPushProvisioningNotification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reqSysId == nil {
		return nil, reportError("reqSysId is required and must be specified")
	}
	if r.sendingProvisioningDataToGooglePayBackendRequest == nil {
		return nil, reportError("sendingProvisioningDataToGooglePayBackendRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "req-sys-id", r.reqSysId, "")
	// body params
	localVarPostBody = r.sendingProvisioningDataToGooglePayBackendRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorMessageFromWebPushProvisioningRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
