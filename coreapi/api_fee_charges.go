/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FeeChargesAPIService FeeChargesAPI service
type FeeChargesAPIService service

type ApiGetFeeChargeTokenRequest struct {
	ctx context.Context
	ApiService *FeeChargesAPIService
	token string
}

func (r ApiGetFeeChargeTokenRequest) Execute() (*FeeTransferResponse, *http.Response, error) {
	return r.ApiService.GetFeeChargeTokenExecute(r)
}

/*
GetFeeChargeToken Retrieve fee charge

Use this endpoint to retrieve a specific fee charge.
Include the fee transfer `token` path parameter to specify the fee charge to return.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the fee charge to retrieve.
 @return ApiGetFeeChargeTokenRequest
*/
func (a *FeeChargesAPIService) GetFeeChargeToken(ctx context.Context, token string) ApiGetFeeChargeTokenRequest {
	return ApiGetFeeChargeTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return FeeTransferResponse
func (a *FeeChargesAPIService) GetFeeChargeTokenExecute(r ApiGetFeeChargeTokenRequest) (*FeeTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeeTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeeChargesAPIService.GetFeeChargeToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feecharges/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFeeChargeRequest struct {
	ctx context.Context
	ApiService *FeeChargesAPIService
	feeTransferRequest *FeeTransferRequest
}

func (r ApiPostFeeChargeRequest) FeeTransferRequest(feeTransferRequest FeeTransferRequest) ApiPostFeeChargeRequest {
	r.feeTransferRequest = &feeTransferRequest
	return r
}

func (r ApiPostFeeChargeRequest) Execute() (*FeeTransferResponse, *http.Response, error) {
	return r.ApiService.PostFeeChargeExecute(r)
}

/*
PostFeeCharge Create fee charge

Use this endpoint to create a fee charge.
You must pass in either `user_token` or `business_token` to associate a user or business with the fee charge.

This is an all-or-nothing operation.
When more than one fee is present, you must assess either all fees, or no fees.

[NOTE]
This feature is currently in beta and subject to change.
It also requires additional activation steps.
To learn more about the Beta program for this feature and about activating it for your program, contact your Marqeta representative.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFeeChargeRequest
*/
func (a *FeeChargesAPIService) PostFeeCharge(ctx context.Context) ApiPostFeeChargeRequest {
	return ApiPostFeeChargeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeeTransferResponse
func (a *FeeChargesAPIService) PostFeeChargeExecute(r ApiPostFeeChargeRequest) (*FeeTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeeTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeeChargesAPIService.PostFeeCharge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feecharges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.feeTransferRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
