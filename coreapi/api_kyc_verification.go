/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// KYCVerificationAPIService KYCVerificationAPI service
type KYCVerificationAPIService service

type ApiGetKycBusinessBusinesstokenRequest struct {
	ctx context.Context
	ApiService *KYCVerificationAPIService
	businessToken string
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
}

// The number of resources to retrieve.
func (r ApiGetKycBusinessBusinesstokenRequest) Count(count int32) ApiGetKycBusinessBusinesstokenRequest {
	r.count = &count
	return r
}

// The sort order index of the first resource in the returned array.
func (r ApiGetKycBusinessBusinesstokenRequest) StartIndex(startIndex int32) ApiGetKycBusinessBusinesstokenRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetKycBusinessBusinesstokenRequest) Fields(fields string) ApiGetKycBusinessBusinesstokenRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetKycBusinessBusinesstokenRequest) SortBy(sortBy string) ApiGetKycBusinessBusinesstokenRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetKycBusinessBusinesstokenRequest) Execute() (*KYCListResponse, *http.Response, error) {
	return r.ApiService.GetKycBusinessBusinesstokenExecute(r)
}

/*
GetKycBusinessBusinesstoken List KYC results for a business

Use this endpoint to retrieve all KYC verification results for a business.

This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.

=== Business KYC outcome reasons (business response)

The following tables describe KYC outcome reasons potentially returned in the `outcome_reasons` field of the business `result` response object when a business is in a `PENDING` or `FAILURE` state.
Where possible, they also describe acceptable documents that your customers can submit to resolve `PENDING` outcomes.

==== Outcome reasons for the business

These outcome reasons pertain to the business organization itself.

[cols=",,2a"]
|===
| Outcome Reason and State | Description | Accepted Documents

| AddressIssue   +
`PENDING`
| Missing, invalid, mismatched, or PO Box address.
| One of the following documents.
Document must show the full business name and address:

* Bank statement
* Utility bill
* Current lease or rental agreement
* Insurance policy

| BusinessNameIssue   +
`PENDING`
| Invalid or mismatched name.
| Articles or certificate of incorporation.

| OFACIssue   +
`FAILURE`
| Business appears on an OFAC list.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| RegistrationIssue   +
`PENDING`
| Business is inactive, not registered, or not in good standing with the Secretary of State; recently reported or not recently updated.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| Sanctions List Non-OFAC   +
`PENDING`
| Business appears on a non-OFAC screening list, bankruptcy, or alert list.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| TINIssue   +
`PENDING`
| Missing, invalid, or mismatched Tax Identification Number (TIN).
| IRS Notice Letter 147C or CP575, or most recent tax return.

|===

===== Outcome reasons for individuals associated with a business

These outcome reasons pertain to individuals associated with a business: proprietors, business officers, and beneficial owners.

[cols=",,2a"]
|===
| Outcome Reason and State | Description | Accepted Documents

| AddressIssue   +
`PENDING`
| Missing, invalid, mismatched, or PO Box address.
| One of the following documents.
Document must show the full name and address:

* Unexpired state-issued driver's license or identification card
* US Military Identification Card
* Utility bill
* Bank statement
* Current rental or lease agreement
* Mortgage statement

| DateofBirthIssue   +
`PENDING`
| Invalid or mismatched date of birth.
| Unexpired government-issued photo identification that shows name and date of birth:

* Driver's license or state-issued identification card
* Passport

| NameIssue   +
`PENDING`
| Invalid or mismatched name.
| Unexpired government-issued photo identification that has name and date of birth:

* Driver's license or state-issued identification card
* Passport or US passport card

| NoRecordFound   +
`FAILURE`
| No records were found for this individual.
| As no record was found for this individual, supporting documentation must be provided for each attribute (name, date of birth, address, and SSN):

* To verify an individual's address, provide one of these documents:
** Unexpired state-issued driver's license or identification card
** US Military Identification Card
** Utility bill
** Bank statement
** Current rental or lease agreement
** Mortgage statement
* To verify an individual's name and date of birth, provide one of these documents:
** Driver's license or state-issued identification card
** Passport
* To verify an individual's Social Security Number, provide one of these documents:
** Social Security card
** Recent W-2 or 1099 showing nine-digit SSN, full name, and address.
** ITIN card or document showing ITIN approval

| OFAC   +
`FAILURE`
| Appears on an Office of Foreign Assets Control (OFAC) list.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| RiskIssue   +
`FAILURE`
| Appears on a non-OFAC screening list, bankruptcy, or alert list, or has an insufficient record.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| SSNFail   +
`FAILURE`
| Social Security Number (SSN) appears on Network Alert List, is of a deceased person, or was issued before the individual's date of birth.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| SSNIssue   +
`PENDING`
| Missing, invalid, or mismatched SSN.
| * Social Security card
* Recent W-2 or 1099 showing nine-digit SSN, full name, and address.
* ITIN card or document showing ITIN approval
|===

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessToken The unique identifier of the business resource for which you want to retrieve KYC verification results.
 @return ApiGetKycBusinessBusinesstokenRequest
*/
func (a *KYCVerificationAPIService) GetKycBusinessBusinesstoken(ctx context.Context, businessToken string) ApiGetKycBusinessBusinesstokenRequest {
	return ApiGetKycBusinessBusinesstokenRequest{
		ApiService: a,
		ctx: ctx,
		businessToken: businessToken,
	}
}

// Execute executes the request
//  @return KYCListResponse
func (a *KYCVerificationAPIService) GetKycBusinessBusinesstokenExecute(r ApiGetKycBusinessBusinesstokenRequest) (*KYCListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KYCListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCVerificationAPIService.GetKycBusinessBusinesstoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kyc/business/{business_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"business_token"+"}", url.PathEscape(parameterValueToString(r.businessToken, "businessToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKycTokenRequest struct {
	ctx context.Context
	ApiService *KYCVerificationAPIService
	token string
}

func (r ApiGetKycTokenRequest) Execute() (*KycResponse, *http.Response, error) {
	return r.ApiService.GetKycTokenExecute(r)
}

/*
GetKycToken Retrieve KYC result

Use this endpoint to retrieve a specific KYC result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the KYC verification for which you want to retrieve the result.
 @return ApiGetKycTokenRequest
*/
func (a *KYCVerificationAPIService) GetKycToken(ctx context.Context, token string) ApiGetKycTokenRequest {
	return ApiGetKycTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return KycResponse
func (a *KYCVerificationAPIService) GetKycTokenExecute(r ApiGetKycTokenRequest) (*KycResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KycResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCVerificationAPIService.GetKycToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kyc/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKycUserUsertokenRequest struct {
	ctx context.Context
	ApiService *KYCVerificationAPIService
	userToken string
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
}

// Number of resources to retrieve.
func (r ApiGetKycUserUsertokenRequest) Count(count int32) ApiGetKycUserUsertokenRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetKycUserUsertokenRequest) StartIndex(startIndex int32) ApiGetKycUserUsertokenRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetKycUserUsertokenRequest) Fields(fields string) ApiGetKycUserUsertokenRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetKycUserUsertokenRequest) SortBy(sortBy string) ApiGetKycUserUsertokenRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetKycUserUsertokenRequest) Execute() (*KYCListResponse, *http.Response, error) {
	return r.ApiService.GetKycUserUsertokenExecute(r)
}

/*
GetKycUserUsertoken List KYC results for a user

Use this endpoint to retrieve all KYC results for a user.

This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.

=== User KYC failure codes

The following table lists KYC failure codes potentially returned in the response when a user does not pass verification.
It also includes a list of acceptable documents that your customers can submit to resolve failures.

[cols=",,2a"]
|===
| Failure Code and State | Description | Accepted Documents

| AddressIssue   +
`FAILURE`
| Missing, invalid, mismatched, or PO Box address.
| One of the following documents.
Document must show the full name and address:

* Unexpired state-issued driver's license or identification card
* US Military Identification Card
* Utility bill
* Bank statement
* Current rental or lease agreement
* Mortgage statement

| DateofBirthIssue   +
`FAILURE`
| Invalid or mismatched date of birth.
| Unexpired government-issued photo identification that shows name and date of birth:

* Driver's license or state-issued identification card
* Passport

| EmailIssue   +
`FAILURE`
| Invalid, insufficient, mismatched, or other risk signal on provided email address.
| Unexpired government-issued photo identification that shows name and date of birth:

* Driver's license or state-issued identification card
* US Passport
* US Military identification Card
* Native American tribal identification card
* Government employee identification card
* Permanent Resident Alien Card

| NameIssue   +
`FAILURE`
| Invalid or mismatched name.
| Unexpired government-issued photo identification that has name and date of birth:

* Driver's license or state-issued identification card
* Passport or US passport card

| NoRecordFound   +
`FAILURE`
| No records were found for this individual.
| As no record was found for this individual, supporting documentation must be provided for each attribute (name, date of birth, address, and SSN):

* To verify an individual's address, provide one of these documents:
** Unexpired state-issued driver's license or identification card
** US Military Identification Card
** Utility bill
** Bank statement
** Current rental or lease agreement
** Mortgage statement
* To verify an individual's name and date of birth, provide one of these documents:
** Driver's license or state-issued identification card
** Passport
* To verify an individual's Social Security Number, provide one of these documents:
** Social Security card
** Recent W-2 or 1099 showing nine-digit SSN, full name, and address.
** ITIN card or document showing ITIN approval

| OFAC   +
`FAILURE`
| Appears on an Office of Foreign Assets Control (OFAC) list.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| PhoneIssue   +
`FAILURE`
| Invalid, insufficient, mismatched, or other risk signal on provided phone number.
| Unexpired government-issued photo identification that shows name and date of birth:

* Driver's license or state-issued identification card
* US Passport
* US Military identification Card
* Native American tribal identification card
* Government employee identification card
* Permanent Resident Alien Card

| RiskIssue   +
`FAILURE`
| Appears on a non-OFAC screening list, bankruptcy, or alert list, or has an insufficient record.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| SSNFail   +
`FAILURE`
| Social Security Number (SSN) appears on Network Alert List, is of a deceased person, or was issued before the individual's date of birth.
| This outcome requires a manual review by Marqeta to determine the next appropriate step.
Contact your Marqeta representative.

| SSNIssue   +
`FAILURE`
| Missing, invalid, or mismatched SSN.
| * Social Security card
* Recent W-2 or 1099 showing nine-digit SSN, full name, and address.
* ITIN card or document showing ITIN approval
|===

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userToken Unique identifier of the user resource for which you want to retrieve KYC verification results.
 @return ApiGetKycUserUsertokenRequest
*/
func (a *KYCVerificationAPIService) GetKycUserUsertoken(ctx context.Context, userToken string) ApiGetKycUserUsertokenRequest {
	return ApiGetKycUserUsertokenRequest{
		ApiService: a,
		ctx: ctx,
		userToken: userToken,
	}
}

// Execute executes the request
//  @return KYCListResponse
func (a *KYCVerificationAPIService) GetKycUserUsertokenExecute(r ApiGetKycUserUsertokenRequest) (*KYCListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KYCListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCVerificationAPIService.GetKycUserUsertoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kyc/user/{user_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_token"+"}", url.PathEscape(parameterValueToString(r.userToken, "userToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostKycRequest struct {
	ctx context.Context
	ApiService *KYCVerificationAPIService
	kycRequest *KycRequest
}

func (r ApiPostKycRequest) KycRequest(kycRequest KycRequest) ApiPostKycRequest {
	r.kycRequest = &kycRequest
	return r
}

func (r ApiPostKycRequest) Execute() (*KycResponse, *http.Response, error) {
	return r.ApiService.PostKycExecute(r)
}

/*
PostKyc Perform KYC verification

Use this endpoint to verify the identity of an account holder in the United States, either a user or a business.
You can perform KYC verification on an account holder, provided the following are true:

* The KYC status of the account holder is `UNVERIFIED` or `LIMITED`
* The account holder has not been submitted for KYC verification twice

=== Required fields

In order to perform KYC verification, the user or business resource on which you perform the check must have the following fields configured with valid values:

[cols="1a,1a"]
|===
| User Fields Required for KYC | Business Fields Required for KYC

|
* `first_name`
* `last_name`
* `address1` (cannot be a PO Box)
* `city`
* `state`
* `postal_code`
* `country`
* `birth_date`
* `ssn` (nine digits, no delimiters)
* `email` (required in some cases)
* `phone` (required in some cases)

|
* `business_name_legal` (128 char max)
* `business_name_dba` ("Doing Business As" or fictitious business name; enter the legal business name in this field if your business does not use a fictitious business name)
* `office_location` (cannot be a PO Box; `state` field must use a <<valid_state_provincial_and_territorial_abbreviations, valid two-letter state, provincial, or territorial abbreviation>>)
* `identifications` (nine digits, no delimiters)
* `incorporation.incorporation_type`
* `incorporation.state_of_incorporation`
* `date_established`
* `proprietor_or_officer`
* `beneficial_owner` (maximum of four beneficial owners)
* `proprietor_is_beneficial_owner` (required if the business proprietor or officer is also a beneficial owner)
* `attestation_consent`
* `attester_name`
* `attestation_date`
|===

==== Valid state, provincial, and territorial abbreviations
The following list includes all valid two-letter abbreviations for US states, territories, and military (APO/FPO/DPO) addresses.
It also includes abbreviations for Canadian provinces and territories.
State, provincial, and territorial abbreviations are case sensitive, and must be in uppercase as they appear in this list:

* `AL`: Alabama
* `AK`: Alaska
* `AB`: Alberta
* `AS`: American Samoa
* `AZ`: Arizona
* `AR`: Arkansas
* `AE`: Armed Forces
* `AA`: Armed Forces Americas
* `AP`: Armed Forces Pacific
* `BC`: British Columbia
* `CA`: California
* `CO`: Colorado
* `CT`: Connecticut
* `DE`: Delaware
* `DC`: District of Columbia
* `FL`: Florida
* `GA`: Georgia
* `GU`: Guam
* `HI`: Hawaii
* `ID`: Idaho
* `IL`: Illinois
* `IN`: Indiana
* `IA`: Iowa
* `KS`: Kansas
* `KY`: Kentucky
* `LA`: Louisiana
* `ME`: Maine
* `MB`: Manitoba
* `MD`: Maryland
* `MA`: Massachusetts
* `MI`: Michigan
* `MN`: Minnesota
* `MS`: Mississippi
* `MO`: Missouri
* `MT`: Montana
* `NE`: Nebraska
* `NV`: Nevada
* `NB`: New Brunswick
* `NH`: New Hampshire
* `NJ`: New Jersey
* `NM`: New Mexico
* `NY`: New York
* `NF`: Newfoundland
* `NC`: North Carolina
* `ND`: North Dakota
* `NT`: Northwest Territories
* `NS`: Nova Scotia
* `NU`: Nunavut
* `OH`: Ohio
* `OK`: Oklahoma
* `ON`: Ontario
* `OR`: Oregon
* `PA`: Pennsylvania
* `PE`: Prince Edward Island
* `PR`: Puerto Rico
* `QC`: Quebec
* `RI`: Rhode Island
* `SK`: Saskatchewan
* `SC`: South Carolina
* `SD`: South Dakota
* `TN`: Tennessee
* `TX`: Texas
* `UT`: Utah
* `VT`: Vermont
* `VI`: Virgin Islands
* `VA`: Virginia
* `WA`: Washington
* `WV`: West Virginia
* `WI`: Wisconsin
* `WY`: Wyoming
* `YT`: Yukon Territory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostKycRequest
*/
func (a *KYCVerificationAPIService) PostKyc(ctx context.Context) ApiPostKycRequest {
	return ApiPostKycRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KycResponse
func (a *KYCVerificationAPIService) PostKycExecute(r ApiPostKycRequest) (*KycResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KycResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KYCVerificationAPIService.PostKyc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/kyc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.kycRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
