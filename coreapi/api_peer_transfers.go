/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PeerTransfersAPIService PeerTransfersAPI service
type PeerTransfersAPIService service

type ApiGetPeertransfersTokenRequest struct {
	ctx context.Context
	ApiService *PeerTransfersAPIService
	token string
}

func (r ApiGetPeertransfersTokenRequest) Execute() (*PeerTransferResponse, *http.Response, error) {
	return r.ApiService.GetPeertransfersTokenExecute(r)
}

/*
GetPeertransfersToken Retrieve peer transfer

Use this endpoint to retrieve a peer transfer request.
Include the peer transfer `token` as a path parameter in the URL to identify the peer transfer to return.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the peer transfer.
 @return ApiGetPeertransfersTokenRequest
*/
func (a *PeerTransfersAPIService) GetPeertransfersToken(ctx context.Context, token string) ApiGetPeertransfersTokenRequest {
	return ApiGetPeertransfersTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PeerTransferResponse
func (a *PeerTransfersAPIService) GetPeertransfersTokenExecute(r ApiGetPeertransfersTokenRequest) (*PeerTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PeerTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeerTransfersAPIService.GetPeertransfersToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/peertransfers/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPeertransfersUserUserorbusinesstokenRequest struct {
	ctx context.Context
	ApiService *PeerTransfersAPIService
	userOrBusinessToken string
	count *int32
	startIndex *int32
	fields *string
}

// Number of peer transfer resources to retrieve.
func (r ApiGetPeertransfersUserUserorbusinesstokenRequest) Count(count int32) ApiGetPeertransfersUserUserorbusinesstokenRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetPeertransfersUserUserorbusinesstokenRequest) StartIndex(startIndex int32) ApiGetPeertransfersUserUserorbusinesstokenRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetPeertransfersUserUserorbusinesstokenRequest) Fields(fields string) ApiGetPeertransfersUserUserorbusinesstokenRequest {
	r.fields = &fields
	return r
}

func (r ApiGetPeertransfersUserUserorbusinesstokenRequest) Execute() (*PeerTransferResponse, *http.Response, error) {
	return r.ApiService.GetPeertransfersUserUserorbusinesstokenExecute(r)
}

/*
GetPeertransfersUserUserorbusinesstoken List peer transfers by account holder

Use this endpoint to list peer transfers sent or received by a particular account holder.
Include a user or business token as a path parameter to identify the account holder whose transfers you want to list.

This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userOrBusinessToken Existing user or business token.  Send a `GET` request to `/users` to retrieve user tokens or to `/businesses` to retrieve business tokens.
 @return ApiGetPeertransfersUserUserorbusinesstokenRequest
*/
func (a *PeerTransfersAPIService) GetPeertransfersUserUserorbusinesstoken(ctx context.Context, userOrBusinessToken string) ApiGetPeertransfersUserUserorbusinesstokenRequest {
	return ApiGetPeertransfersUserUserorbusinesstokenRequest{
		ApiService: a,
		ctx: ctx,
		userOrBusinessToken: userOrBusinessToken,
	}
}

// Execute executes the request
//  @return PeerTransferResponse
func (a *PeerTransfersAPIService) GetPeertransfersUserUserorbusinesstokenExecute(r ApiGetPeertransfersUserUserorbusinesstokenRequest) (*PeerTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PeerTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeerTransfersAPIService.GetPeertransfersUserUserorbusinesstoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/peertransfers/user/{user_or_business_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_or_business_token"+"}", url.PathEscape(parameterValueToString(r.userOrBusinessToken, "userOrBusinessToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 25
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest struct {
	ctx context.Context
	ApiService *PeerTransfersAPIService
	userOrBusinessToken string
	count *int32
	startIndex *int32
	fields *string
}

// Number of peer transfer resources to retrieve.
func (r ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest) Count(count int32) ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest) StartIndex(startIndex int32) ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest) Fields(fields string) ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest {
	r.fields = &fields
	return r
}

func (r ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest) Execute() (*PeerTransferResponse, *http.Response, error) {
	return r.ApiService.GetPeertransfersUserUserorbusinesstokenRecipientExecute(r)
}

/*
GetPeertransfersUserUserorbusinesstokenRecipient List received peer transfers

Use this endpoint to list peer transfers sent by an account holder.
Include a user or business token as a path parameter to identify the recipient.

This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userOrBusinessToken Existing user or business token.  Send a `GET` request to `/users` to retrieve user tokens or to `/businesses` to retrieve business tokens.
 @return ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest
*/
func (a *PeerTransfersAPIService) GetPeertransfersUserUserorbusinesstokenRecipient(ctx context.Context, userOrBusinessToken string) ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest {
	return ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest{
		ApiService: a,
		ctx: ctx,
		userOrBusinessToken: userOrBusinessToken,
	}
}

// Execute executes the request
//  @return PeerTransferResponse
func (a *PeerTransfersAPIService) GetPeertransfersUserUserorbusinesstokenRecipientExecute(r ApiGetPeertransfersUserUserorbusinesstokenRecipientRequest) (*PeerTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PeerTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeerTransfersAPIService.GetPeertransfersUserUserorbusinesstokenRecipient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/peertransfers/user/{user_or_business_token}/recipient"
	localVarPath = strings.Replace(localVarPath, "{"+"user_or_business_token"+"}", url.PathEscape(parameterValueToString(r.userOrBusinessToken, "userOrBusinessToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 25
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPeertransfersUserUserorbusinesstokenSenderRequest struct {
	ctx context.Context
	ApiService *PeerTransfersAPIService
	userOrBusinessToken string
	count *int32
	startIndex *int32
	fields *string
}

// Number of peer transfer resources to retrieve.
func (r ApiGetPeertransfersUserUserorbusinesstokenSenderRequest) Count(count int32) ApiGetPeertransfersUserUserorbusinesstokenSenderRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetPeertransfersUserUserorbusinesstokenSenderRequest) StartIndex(startIndex int32) ApiGetPeertransfersUserUserorbusinesstokenSenderRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetPeertransfersUserUserorbusinesstokenSenderRequest) Fields(fields string) ApiGetPeertransfersUserUserorbusinesstokenSenderRequest {
	r.fields = &fields
	return r
}

func (r ApiGetPeertransfersUserUserorbusinesstokenSenderRequest) Execute() (*PeerTransferResponse, *http.Response, error) {
	return r.ApiService.GetPeertransfersUserUserorbusinesstokenSenderExecute(r)
}

/*
GetPeertransfersUserUserorbusinesstokenSender List sent peer transfers

Use this endpoint to list peer transfers sent by an account holder.
Include a user or business token as a path parameter to identify the sender.

This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userOrBusinessToken Existing user or business token.  Send a `GET` request to `/users` to retrieve user tokens or to `/businesses` to retrieve business tokens.
 @return ApiGetPeertransfersUserUserorbusinesstokenSenderRequest
*/
func (a *PeerTransfersAPIService) GetPeertransfersUserUserorbusinesstokenSender(ctx context.Context, userOrBusinessToken string) ApiGetPeertransfersUserUserorbusinesstokenSenderRequest {
	return ApiGetPeertransfersUserUserorbusinesstokenSenderRequest{
		ApiService: a,
		ctx: ctx,
		userOrBusinessToken: userOrBusinessToken,
	}
}

// Execute executes the request
//  @return PeerTransferResponse
func (a *PeerTransfersAPIService) GetPeertransfersUserUserorbusinesstokenSenderExecute(r ApiGetPeertransfersUserUserorbusinesstokenSenderRequest) (*PeerTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PeerTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeerTransfersAPIService.GetPeertransfersUserUserorbusinesstokenSender")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/peertransfers/user/{user_or_business_token}/sender"
	localVarPath = strings.Replace(localVarPath, "{"+"user_or_business_token"+"}", url.PathEscape(parameterValueToString(r.userOrBusinessToken, "userOrBusinessToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 25
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPeertransfersRequest struct {
	ctx context.Context
	ApiService *PeerTransfersAPIService
	peerTransferRequest *PeerTransferRequest
}

func (r ApiPostPeertransfersRequest) PeerTransferRequest(peerTransferRequest PeerTransferRequest) ApiPostPeertransfersRequest {
	r.peerTransferRequest = &peerTransferRequest
	return r
}

func (r ApiPostPeertransfersRequest) Execute() (*PeerTransferResponse, *http.Response, error) {
	return r.ApiService.PostPeertransfersExecute(r)
}

/*
PostPeertransfers Create peer transfer

Use this endpoint to request a peer transfer (i.e., a movement of funds from the GPA of an account holder to another account belonging to the same account holder).
Add the source details to the body of the request in link:http://www.json.org/[JSON, window="_blank"] format.

When creating a peer transfer request, you must pass in both a token to identify the fee sender (either `sender_user_token` or `sender_business_token`) and a token to identify the fee recipient (either `recipient_user_token` or `recipient_business_token`).
The sender and recipient objects must already exist.

[NOTE]
This feature is disabled by default and requires activation by Marqeta.   +
  +
This feature enables you to transfer or reallocate funds where the `sender_*\_token` and the `recipient_*_token` belong to the same account holder.
It does not allow you to transfer or reallocate funds between different account holders.
Contact your Marqeta representative for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostPeertransfersRequest
*/
func (a *PeerTransfersAPIService) PostPeertransfers(ctx context.Context) ApiPostPeertransfersRequest {
	return ApiPostPeertransfersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PeerTransferResponse
func (a *PeerTransfersAPIService) PostPeertransfersExecute(r ApiPostPeertransfersRequest) (*PeerTransferResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PeerTransferResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PeerTransfersAPIService.PostPeertransfers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/peertransfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.peerTransferRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
