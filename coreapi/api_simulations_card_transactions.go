/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SimulationsCardTransactionsAPIService SimulationsCardTransactionsAPI service
type SimulationsCardTransactionsAPIService service

type ApiAccountFundingAuthPlusCaptureEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthPlusCaptureEvent *AccountFundingAuthPlusCaptureEvent
}

func (r ApiAccountFundingAuthPlusCaptureEventRequest) AccountFundingAuthPlusCaptureEvent(accountFundingAuthPlusCaptureEvent AccountFundingAuthPlusCaptureEvent) ApiAccountFundingAuthPlusCaptureEventRequest {
	r.accountFundingAuthPlusCaptureEvent = &accountFundingAuthPlusCaptureEvent
	return r
}

func (r ApiAccountFundingAuthPlusCaptureEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthPlusCaptureEventExecute(r)
}

/*
AccountFundingAuthPlusCaptureEvent Simulate AFT authorization and capture

Use this endpoint to simulate `account.funding.auth_plus_capture` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthPlusCaptureEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureEvent(ctx context.Context) ApiAccountFundingAuthPlusCaptureEventRequest {
	return ApiAccountFundingAuthPlusCaptureEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureEventExecute(r ApiAccountFundingAuthPlusCaptureEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthPlusCaptureEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.auth_plus_capture"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthPlusCaptureEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthPlusCaptureReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthPlusCaptureReversalEvent *AccountFundingAuthPlusCaptureReversalEvent
}

func (r ApiAccountFundingAuthPlusCaptureReversalEventRequest) AccountFundingAuthPlusCaptureReversalEvent(accountFundingAuthPlusCaptureReversalEvent AccountFundingAuthPlusCaptureReversalEvent) ApiAccountFundingAuthPlusCaptureReversalEventRequest {
	r.accountFundingAuthPlusCaptureReversalEvent = &accountFundingAuthPlusCaptureReversalEvent
	return r
}

func (r ApiAccountFundingAuthPlusCaptureReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthPlusCaptureReversalEventExecute(r)
}

/*
AccountFundingAuthPlusCaptureReversalEvent Simulate AFT authorization and capture reversal

Use this endpoint to simulate `account.funding.auth_plus_capture.reversal` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthPlusCaptureReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureReversalEvent(ctx context.Context) ApiAccountFundingAuthPlusCaptureReversalEventRequest {
	return ApiAccountFundingAuthPlusCaptureReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureReversalEventExecute(r ApiAccountFundingAuthPlusCaptureReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthPlusCaptureReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.auth_plus_capture.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthPlusCaptureReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthorizationClearingEvent *AccountFundingAuthorizationClearingEvent
}

func (r ApiAccountFundingAuthorizationClearingEventRequest) AccountFundingAuthorizationClearingEvent(accountFundingAuthorizationClearingEvent AccountFundingAuthorizationClearingEvent) ApiAccountFundingAuthorizationClearingEventRequest {
	r.accountFundingAuthorizationClearingEvent = &accountFundingAuthorizationClearingEvent
	return r
}

func (r ApiAccountFundingAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthorizationClearingEventExecute(r)
}

/*
AccountFundingAuthorizationClearingEvent Simulate AFT authorization clearing

Use this endpoint to simulate `account.funding.authorization.clearing` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationClearingEvent(ctx context.Context) ApiAccountFundingAuthorizationClearingEventRequest {
	return ApiAccountFundingAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationClearingEventExecute(r ApiAccountFundingAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthorizationEvent *AccountFundingAuthorizationEvent
}

func (r ApiAccountFundingAuthorizationEventRequest) AccountFundingAuthorizationEvent(accountFundingAuthorizationEvent AccountFundingAuthorizationEvent) ApiAccountFundingAuthorizationEventRequest {
	r.accountFundingAuthorizationEvent = &accountFundingAuthorizationEvent
	return r
}

func (r ApiAccountFundingAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthorizationEventExecute(r)
}

/*
AccountFundingAuthorizationEvent Simulate AFT authorization

Use this endpoint to simulate Account Funding Transactions (AFTs) using `account.funding.authorization`.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationEvent(ctx context.Context) ApiAccountFundingAuthorizationEventRequest {
	return ApiAccountFundingAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationEventExecute(r ApiAccountFundingAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthorizationReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthorizationReversalEvent *AccountFundingAuthorizationReversalEvent
}

func (r ApiAccountFundingAuthorizationReversalEventRequest) AccountFundingAuthorizationReversalEvent(accountFundingAuthorizationReversalEvent AccountFundingAuthorizationReversalEvent) ApiAccountFundingAuthorizationReversalEventRequest {
	r.accountFundingAuthorizationReversalEvent = &accountFundingAuthorizationReversalEvent
	return r
}

func (r ApiAccountFundingAuthorizationReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthorizationReversalEventExecute(r)
}

/*
AccountFundingAuthorizationReversalEvent Simulate AFT authorization reversal

Use this endpoint to simulate `account.funding.authorization.reversal` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthorizationReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationReversalEvent(ctx context.Context) ApiAccountFundingAuthorizationReversalEventRequest {
	return ApiAccountFundingAuthorizationReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationReversalEventExecute(r ApiAccountFundingAuthorizationReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthorizationReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.authorization.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthorizationReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationAdviceEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationAdviceEvent *AuthorizationAdviceEvent
}

func (r ApiAuthorizationAdviceEventRequest) AuthorizationAdviceEvent(authorizationAdviceEvent AuthorizationAdviceEvent) ApiAuthorizationAdviceEventRequest {
	r.authorizationAdviceEvent = &authorizationAdviceEvent
	return r
}

func (r ApiAuthorizationAdviceEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationAdviceEventExecute(r)
}

/*
AuthorizationAdviceEvent Simulate authorization advice

Authorization advice allows an amount to be decreased after the authorization.
This endpoint allows you to simulate post-swipe adjustments.
Simulate an `authorization.advice` transaction by including the `preceding_related_transaction_token` and other authorization details in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationAdviceEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationAdviceEvent(ctx context.Context) ApiAuthorizationAdviceEventRequest {
	return ApiAuthorizationAdviceEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationAdviceEventExecute(r ApiAuthorizationAdviceEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationAdviceEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.advice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationAdviceEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationAtmWithdrawalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationAtmWithdrawalEvent *AuthorizationAtmWithdrawalEvent
}

func (r ApiAuthorizationAtmWithdrawalEventRequest) AuthorizationAtmWithdrawalEvent(authorizationAtmWithdrawalEvent AuthorizationAtmWithdrawalEvent) ApiAuthorizationAtmWithdrawalEventRequest {
	r.authorizationAtmWithdrawalEvent = &authorizationAtmWithdrawalEvent
	return r
}

func (r ApiAuthorizationAtmWithdrawalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationAtmWithdrawalEventExecute(r)
}

/*
AuthorizationAtmWithdrawalEvent Simulate ATM withdrawal authorization

Use this endpoint to simulate `authorization.atm.withdrawal` transactions.
In the EU, this includes authorization for withdrawing cash at an ATM.
In the US, this event indicates that the cardholder got cash from a bank teller rather than an ATM.
This simulation can be used to test dual-message ATM withdrawal transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationAtmWithdrawalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationAtmWithdrawalEvent(ctx context.Context) ApiAuthorizationAtmWithdrawalEventRequest {
	return ApiAuthorizationAtmWithdrawalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationAtmWithdrawalEventExecute(r ApiAuthorizationAtmWithdrawalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationAtmWithdrawalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.atm.withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationAtmWithdrawalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationCashbackEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationCashbackEvent *AuthorizationCashbackEvent
}

func (r ApiAuthorizationCashbackEventRequest) AuthorizationCashbackEvent(authorizationCashbackEvent AuthorizationCashbackEvent) ApiAuthorizationCashbackEventRequest {
	r.authorizationCashbackEvent = &authorizationCashbackEvent
	return r
}

func (r ApiAuthorizationCashbackEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationCashbackEventExecute(r)
}

/*
AuthorizationCashbackEvent Simulate authorization cash back

Use this endpoint to simulate `authorization.cashback` transactions, which covers authorization for cash back requested at a point-of-sale terminal.
This simulation can be used to test dual-message cash back transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationCashbackEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationCashbackEvent(ctx context.Context) ApiAuthorizationCashbackEventRequest {
	return ApiAuthorizationCashbackEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationCashbackEventExecute(r ApiAuthorizationCashbackEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationCashbackEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.cashback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationCashbackEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationClearingAtmWithdrawalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationClearingAtmWithdrawalEvent *AuthorizationClearingAtmWithdrawalEvent
}

func (r ApiAuthorizationClearingAtmWithdrawalEventRequest) AuthorizationClearingAtmWithdrawalEvent(authorizationClearingAtmWithdrawalEvent AuthorizationClearingAtmWithdrawalEvent) ApiAuthorizationClearingAtmWithdrawalEventRequest {
	r.authorizationClearingAtmWithdrawalEvent = &authorizationClearingAtmWithdrawalEvent
	return r
}

func (r ApiAuthorizationClearingAtmWithdrawalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationClearingAtmWithdrawalEventExecute(r)
}

/*
AuthorizationClearingAtmWithdrawalEvent Simulate ATM withdrawal authorization clearing

Use this endpoint to simulate `authorization.clearing.atm.withdrawal` transactions, which completes an authorization for withdrawing cash at an ATM.
This simulation can be used to test dual-message ATM withdrawal transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationClearingAtmWithdrawalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingAtmWithdrawalEvent(ctx context.Context) ApiAuthorizationClearingAtmWithdrawalEventRequest {
	return ApiAuthorizationClearingAtmWithdrawalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingAtmWithdrawalEventExecute(r ApiAuthorizationClearingAtmWithdrawalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationClearingAtmWithdrawalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.clearing.atm.withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationClearingAtmWithdrawalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationClearingEvent *AuthorizationClearingEvent
}

func (r ApiAuthorizationClearingEventRequest) AuthorizationClearingEvent(authorizationClearingEvent AuthorizationClearingEvent) ApiAuthorizationClearingEventRequest {
	r.authorizationClearingEvent = &authorizationClearingEvent
	return r
}

func (r ApiAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationClearingEventExecute(r)
}

/*
AuthorizationClearingEvent Simulate authorization clearing

Clearing is the process of finalizing the hold on funds and posting the transaction on the cardholder's account.
This process is triggered by the merchant's capture request.
This endpoint simulates an `authorization.clearing` type transaction by including the `preceding_related_transaction_token` and `amount` in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingEvent(ctx context.Context) ApiAuthorizationClearingEventRequest {
	return ApiAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingEventExecute(r ApiAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationClearingQuasiCashEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationClearingQuasiCashEvent *AuthorizationClearingQuasiCashEvent
}

func (r ApiAuthorizationClearingQuasiCashEventRequest) AuthorizationClearingQuasiCashEvent(authorizationClearingQuasiCashEvent AuthorizationClearingQuasiCashEvent) ApiAuthorizationClearingQuasiCashEventRequest {
	r.authorizationClearingQuasiCashEvent = &authorizationClearingQuasiCashEvent
	return r
}

func (r ApiAuthorizationClearingQuasiCashEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationClearingQuasiCashEventExecute(r)
}

/*
AuthorizationClearingQuasiCashEvent Simulate quasi-cash authorization clearing

Use this endpoint to simulate `authorization.clearing.quasi.cash` transactions, which completes an authorization at a point-of-sale terminal for items equivalent to cash, such as traveler's checks, money orders, foreign currency, or gaming chips.
This simulation can be used to test dual-message quasi-cash transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationClearingQuasiCashEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingQuasiCashEvent(ctx context.Context) ApiAuthorizationClearingQuasiCashEventRequest {
	return ApiAuthorizationClearingQuasiCashEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingQuasiCashEventExecute(r ApiAuthorizationClearingQuasiCashEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationClearingQuasiCashEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.clearing.quasi.cash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationClearingQuasiCashEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationEvent *AuthorizationEvent
}

func (r ApiAuthorizationEventRequest) AuthorizationEvent(authorizationEvent AuthorizationEvent) ApiAuthorizationEventRequest {
	r.authorizationEvent = &authorizationEvent
	return r
}

func (r ApiAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationEventExecute(r)
}

/*
AuthorizationEvent Simulate authorization

Authorization is the process of confirming whether a card is valid, business rules are met, and funds are sufficient, and then placing a temporary hold on those funds.
Use this endpoint to simulate an `authorization` type transaction by including the `card_token` and other authorization details in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationEvent(ctx context.Context) ApiAuthorizationEventRequest {
	return ApiAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationEventExecute(r ApiAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationIncrementalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationIncrementalEvent *AuthorizationIncrementalEvent
}

func (r ApiAuthorizationIncrementalEventRequest) AuthorizationIncrementalEvent(authorizationIncrementalEvent AuthorizationIncrementalEvent) ApiAuthorizationIncrementalEventRequest {
	r.authorizationIncrementalEvent = &authorizationIncrementalEvent
	return r
}

func (r ApiAuthorizationIncrementalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationIncrementalEventExecute(r)
}

/*
AuthorizationIncrementalEvent Simulate incremental authorization

Use this endpoint to simulate incremental authorization transactions.
An incremental authorization is a request to add an additional dollar amount to an ongoing prior authorization.
This type of transaction enables you to increase the final amount authorized as conditions change or additional charges accrue.
A common use case is adding the gratuity (an incremental authorization) to the original total (a prior authorization) of a restaurant bill.
For this use case, you use two endpoints: one to create the authorization, and another to increment it.
* Create the authorization using the `/simulations/cardtransactions/authorization` endpoint:  +
*Action:* `POST`  +
*Endpoint:* `/simulations/cardtransactions/authorization`
* Increment the authorization using the `/simulations/cardtransactions/authorization.incremental` endpoint:  +
*Action:* `POST`  +
*Endpoint:* `/simulations/cardtransactions/authorization.incremental`
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationIncrementalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationIncrementalEvent(ctx context.Context) ApiAuthorizationIncrementalEventRequest {
	return ApiAuthorizationIncrementalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationIncrementalEventExecute(r ApiAuthorizationIncrementalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationIncrementalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.incremental"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationIncrementalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationQuasiCashEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationQuasiCashEvent *AuthorizationQuasiCashEvent
}

func (r ApiAuthorizationQuasiCashEventRequest) AuthorizationQuasiCashEvent(authorizationQuasiCashEvent AuthorizationQuasiCashEvent) ApiAuthorizationQuasiCashEventRequest {
	r.authorizationQuasiCashEvent = &authorizationQuasiCashEvent
	return r
}

func (r ApiAuthorizationQuasiCashEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationQuasiCashEventExecute(r)
}

/*
AuthorizationQuasiCashEvent Simulate quasi-cash authorization

Use this endpoint to simulate `authorization.quasi.cash` transactions.
This is for authorization at a point-of-sale terminal for items equivalent to cash, such as traveler's checks, money orders, foreign currency, or gaming chips.
This simulation can be used to test dual-message quasi-cash transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationQuasiCashEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationQuasiCashEvent(ctx context.Context) ApiAuthorizationQuasiCashEventRequest {
	return ApiAuthorizationQuasiCashEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationQuasiCashEventExecute(r ApiAuthorizationQuasiCashEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationQuasiCashEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.quasi.cash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationQuasiCashEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationReversalEvent *AuthorizationReversalEvent
}

func (r ApiAuthorizationReversalEventRequest) AuthorizationReversalEvent(authorizationReversalEvent AuthorizationReversalEvent) ApiAuthorizationReversalEventRequest {
	r.authorizationReversalEvent = &authorizationReversalEvent
	return r
}

func (r ApiAuthorizationReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationReversalEventExecute(r)
}

/*
AuthorizationReversalEvent Simulate authorization reversal

A reversal releases the hold that was placed on account funds by an authorization, thus returning the funds to the account.
This endpoint simulates an `authorization.reversal` type transaction by including the `original_transaction_token` and `amount` in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationReversalEvent(ctx context.Context) ApiAuthorizationReversalEventRequest {
	return ApiAuthorizationReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationReversalEventExecute(r ApiAuthorizationReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundAuthorizationClearingEvent *RefundAuthorizationClearingEvent
}

func (r ApiRefundAuthorizationClearingEventRequest) RefundAuthorizationClearingEvent(refundAuthorizationClearingEvent RefundAuthorizationClearingEvent) ApiRefundAuthorizationClearingEventRequest {
	r.refundAuthorizationClearingEvent = &refundAuthorizationClearingEvent
	return r
}

func (r ApiRefundAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundAuthorizationClearingEventExecute(r)
}

/*
RefundAuthorizationClearingEvent Simulate refund authorization clearing

Use this endpoint to simulate online refund clearing.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationClearingEvent(ctx context.Context) ApiRefundAuthorizationClearingEventRequest {
	return ApiRefundAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationClearingEventExecute(r ApiRefundAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundAuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund.authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundAuthorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundAuthorizationEvent *RefundAuthorizationEvent
}

func (r ApiRefundAuthorizationEventRequest) RefundAuthorizationEvent(refundAuthorizationEvent RefundAuthorizationEvent) ApiRefundAuthorizationEventRequest {
	r.refundAuthorizationEvent = &refundAuthorizationEvent
	return r
}

func (r ApiRefundAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundAuthorizationEventExecute(r)
}

/*
RefundAuthorizationEvent Simulate refund authorization

Online refund refers to the `refund.authorization` messages that Visa and Mastercard merchants can send to card issuers.
These refund authorizations allow merchants to notify customers of a pending refund and give card issuers the opportunity to decline a refund.
Like purchase authorizations, refund authorizations are eventually cleared or completed by a `refund.authorization.clearing` event.
That refund authorization clearing is automatically accepted and processed by the Marqeta platform, regardless of your funding model.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationEvent(ctx context.Context) ApiRefundAuthorizationEventRequest {
	return ApiRefundAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationEventExecute(r ApiRefundAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundAuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund.authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundAuthorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundAuthorizationReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundAuthorizationReversalEvent *RefundAuthorizationReversalEvent
}

func (r ApiRefundAuthorizationReversalEventRequest) RefundAuthorizationReversalEvent(refundAuthorizationReversalEvent RefundAuthorizationReversalEvent) ApiRefundAuthorizationReversalEventRequest {
	r.refundAuthorizationReversalEvent = &refundAuthorizationReversalEvent
	return r
}

func (r ApiRefundAuthorizationReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundAuthorizationReversalEventExecute(r)
}

/*
RefundAuthorizationReversalEvent Simulate refund authorization reversal

Use this endpoint to reject `refund.authorization` transactions for online refunds.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundAuthorizationReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationReversalEvent(ctx context.Context) ApiRefundAuthorizationReversalEventRequest {
	return ApiRefundAuthorizationReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationReversalEventExecute(r ApiRefundAuthorizationReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundAuthorizationReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund.authorization.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundAuthorizationReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundEvent *RefundEvent
}

func (r ApiRefundEventRequest) RefundEvent(refundEvent RefundEvent) ApiRefundEventRequest {
	r.refundEvent = &refundEvent
	return r
}

func (r ApiRefundEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundEventExecute(r)
}

/*
RefundEvent Simulate refund

Use this endpoint to simulate an offline refund.
Refunds are not associated with a token, so a `preceding_related_transaction_token` is not needed.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundEvent(ctx context.Context) ApiRefundEventRequest {
	return ApiRefundEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundEventExecute(r ApiRefundEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
