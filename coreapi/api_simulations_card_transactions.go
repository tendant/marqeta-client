/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SimulationsCardTransactionsAPIService SimulationsCardTransactionsAPI service
type SimulationsCardTransactionsAPIService service

type ApiAccountFundingAuthPlusCaptureEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthPlusCaptureEvent *AccountFundingAuthPlusCaptureEvent
}

func (r ApiAccountFundingAuthPlusCaptureEventRequest) AccountFundingAuthPlusCaptureEvent(accountFundingAuthPlusCaptureEvent AccountFundingAuthPlusCaptureEvent) ApiAccountFundingAuthPlusCaptureEventRequest {
	r.accountFundingAuthPlusCaptureEvent = &accountFundingAuthPlusCaptureEvent
	return r
}

func (r ApiAccountFundingAuthPlusCaptureEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthPlusCaptureEventExecute(r)
}

/*
AccountFundingAuthPlusCaptureEvent Simulate AFT authorization and capture

Use this endpoint to simulate `account.funding.auth_plus_capture` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthPlusCaptureEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureEvent(ctx context.Context) ApiAccountFundingAuthPlusCaptureEventRequest {
	return ApiAccountFundingAuthPlusCaptureEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureEventExecute(r ApiAccountFundingAuthPlusCaptureEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthPlusCaptureEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.auth_plus_capture"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthPlusCaptureEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthPlusCaptureReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthPlusCaptureReversalEvent *AccountFundingAuthPlusCaptureReversalEvent
}

func (r ApiAccountFundingAuthPlusCaptureReversalEventRequest) AccountFundingAuthPlusCaptureReversalEvent(accountFundingAuthPlusCaptureReversalEvent AccountFundingAuthPlusCaptureReversalEvent) ApiAccountFundingAuthPlusCaptureReversalEventRequest {
	r.accountFundingAuthPlusCaptureReversalEvent = &accountFundingAuthPlusCaptureReversalEvent
	return r
}

func (r ApiAccountFundingAuthPlusCaptureReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthPlusCaptureReversalEventExecute(r)
}

/*
AccountFundingAuthPlusCaptureReversalEvent Simulate AFT authorization and capture reversal

Use this endpoint to simulate `account.funding.auth_plus_capture.reversal` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthPlusCaptureReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureReversalEvent(ctx context.Context) ApiAccountFundingAuthPlusCaptureReversalEventRequest {
	return ApiAccountFundingAuthPlusCaptureReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthPlusCaptureReversalEventExecute(r ApiAccountFundingAuthPlusCaptureReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthPlusCaptureReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.auth_plus_capture.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthPlusCaptureReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthorizationClearingEvent *AccountFundingAuthorizationClearingEvent
}

func (r ApiAccountFundingAuthorizationClearingEventRequest) AccountFundingAuthorizationClearingEvent(accountFundingAuthorizationClearingEvent AccountFundingAuthorizationClearingEvent) ApiAccountFundingAuthorizationClearingEventRequest {
	r.accountFundingAuthorizationClearingEvent = &accountFundingAuthorizationClearingEvent
	return r
}

func (r ApiAccountFundingAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthorizationClearingEventExecute(r)
}

/*
AccountFundingAuthorizationClearingEvent Simulate AFT authorization clearing

Use this endpoint to simulate `account.funding.authorization.clearing` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationClearingEvent(ctx context.Context) ApiAccountFundingAuthorizationClearingEventRequest {
	return ApiAccountFundingAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationClearingEventExecute(r ApiAccountFundingAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthorizationEvent *AccountFundingAuthorizationEvent
}

func (r ApiAccountFundingAuthorizationEventRequest) AccountFundingAuthorizationEvent(accountFundingAuthorizationEvent AccountFundingAuthorizationEvent) ApiAccountFundingAuthorizationEventRequest {
	r.accountFundingAuthorizationEvent = &accountFundingAuthorizationEvent
	return r
}

func (r ApiAccountFundingAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthorizationEventExecute(r)
}

/*
AccountFundingAuthorizationEvent Simulate AFT authorization

Use this endpoint to simulate Account Funding Transactions (AFTs) using `account.funding.authorization`.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationEvent(ctx context.Context) ApiAccountFundingAuthorizationEventRequest {
	return ApiAccountFundingAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationEventExecute(r ApiAccountFundingAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountFundingAuthorizationReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	accountFundingAuthorizationReversalEvent *AccountFundingAuthorizationReversalEvent
}

func (r ApiAccountFundingAuthorizationReversalEventRequest) AccountFundingAuthorizationReversalEvent(accountFundingAuthorizationReversalEvent AccountFundingAuthorizationReversalEvent) ApiAccountFundingAuthorizationReversalEventRequest {
	r.accountFundingAuthorizationReversalEvent = &accountFundingAuthorizationReversalEvent
	return r
}

func (r ApiAccountFundingAuthorizationReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AccountFundingAuthorizationReversalEventExecute(r)
}

/*
AccountFundingAuthorizationReversalEvent Simulate AFT authorization reversal

Use this endpoint to simulate `account.funding.authorization.reversal` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountFundingAuthorizationReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationReversalEvent(ctx context.Context) ApiAccountFundingAuthorizationReversalEventRequest {
	return ApiAccountFundingAuthorizationReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AccountFundingAuthorizationReversalEventExecute(r ApiAccountFundingAuthorizationReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AccountFundingAuthorizationReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/account.funding.authorization.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountFundingAuthorizationReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationAdviceEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationAdviceEvent *AuthorizationAdviceEvent
}

func (r ApiAuthorizationAdviceEventRequest) AuthorizationAdviceEvent(authorizationAdviceEvent AuthorizationAdviceEvent) ApiAuthorizationAdviceEventRequest {
	r.authorizationAdviceEvent = &authorizationAdviceEvent
	return r
}

func (r ApiAuthorizationAdviceEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationAdviceEventExecute(r)
}

/*
AuthorizationAdviceEvent Simulate authorization advice

Authorization advice allows an amount to be decreased after the authorization.
This endpoint allows you to simulate post-swipe adjustments.
Simulate an `authorization.advice` transaction by including the `preceding_related_transaction_token` and other authorization details in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationAdviceEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationAdviceEvent(ctx context.Context) ApiAuthorizationAdviceEventRequest {
	return ApiAuthorizationAdviceEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationAdviceEventExecute(r ApiAuthorizationAdviceEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationAdviceEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.advice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationAdviceEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationAtmWithdrawalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationAtmWithdrawalEvent *AuthorizationAtmWithdrawalEvent
}

func (r ApiAuthorizationAtmWithdrawalEventRequest) AuthorizationAtmWithdrawalEvent(authorizationAtmWithdrawalEvent AuthorizationAtmWithdrawalEvent) ApiAuthorizationAtmWithdrawalEventRequest {
	r.authorizationAtmWithdrawalEvent = &authorizationAtmWithdrawalEvent
	return r
}

func (r ApiAuthorizationAtmWithdrawalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationAtmWithdrawalEventExecute(r)
}

/*
AuthorizationAtmWithdrawalEvent Simulate ATM withdrawal authorization

Use this endpoint to simulate `authorization.atm.withdrawal` transactions.
In the EU, this includes authorization for withdrawing cash at an ATM.
In the US, this event indicates that the cardholder got cash from a bank teller rather than an ATM.
This simulation can be used to test dual-message ATM withdrawal transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationAtmWithdrawalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationAtmWithdrawalEvent(ctx context.Context) ApiAuthorizationAtmWithdrawalEventRequest {
	return ApiAuthorizationAtmWithdrawalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationAtmWithdrawalEventExecute(r ApiAuthorizationAtmWithdrawalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationAtmWithdrawalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.atm.withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationAtmWithdrawalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationCashbackEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationCashbackEvent *AuthorizationCashbackEvent
}

func (r ApiAuthorizationCashbackEventRequest) AuthorizationCashbackEvent(authorizationCashbackEvent AuthorizationCashbackEvent) ApiAuthorizationCashbackEventRequest {
	r.authorizationCashbackEvent = &authorizationCashbackEvent
	return r
}

func (r ApiAuthorizationCashbackEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationCashbackEventExecute(r)
}

/*
AuthorizationCashbackEvent Simulate authorization cash back

Use this endpoint to simulate `authorization.cashback` transactions, which covers authorization for cash back requested at a point-of-sale terminal.
This simulation can be used to test dual-message cash back transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationCashbackEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationCashbackEvent(ctx context.Context) ApiAuthorizationCashbackEventRequest {
	return ApiAuthorizationCashbackEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationCashbackEventExecute(r ApiAuthorizationCashbackEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationCashbackEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.cashback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationCashbackEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationClearingAtmWithdrawalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationClearingAtmWithdrawalEvent *AuthorizationClearingAtmWithdrawalEvent
}

func (r ApiAuthorizationClearingAtmWithdrawalEventRequest) AuthorizationClearingAtmWithdrawalEvent(authorizationClearingAtmWithdrawalEvent AuthorizationClearingAtmWithdrawalEvent) ApiAuthorizationClearingAtmWithdrawalEventRequest {
	r.authorizationClearingAtmWithdrawalEvent = &authorizationClearingAtmWithdrawalEvent
	return r
}

func (r ApiAuthorizationClearingAtmWithdrawalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationClearingAtmWithdrawalEventExecute(r)
}

/*
AuthorizationClearingAtmWithdrawalEvent Simulate ATM withdrawal authorization clearing

Use this endpoint to simulate `authorization.clearing.atm.withdrawal` transactions, which completes an authorization for withdrawing cash at an ATM.
This simulation can be used to test dual-message ATM withdrawal transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationClearingAtmWithdrawalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingAtmWithdrawalEvent(ctx context.Context) ApiAuthorizationClearingAtmWithdrawalEventRequest {
	return ApiAuthorizationClearingAtmWithdrawalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingAtmWithdrawalEventExecute(r ApiAuthorizationClearingAtmWithdrawalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationClearingAtmWithdrawalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.clearing.atm.withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationClearingAtmWithdrawalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationClearingEvent *AuthorizationClearingEvent
}

func (r ApiAuthorizationClearingEventRequest) AuthorizationClearingEvent(authorizationClearingEvent AuthorizationClearingEvent) ApiAuthorizationClearingEventRequest {
	r.authorizationClearingEvent = &authorizationClearingEvent
	return r
}

func (r ApiAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationClearingEventExecute(r)
}

/*
AuthorizationClearingEvent Simulate authorization clearing

Clearing is the process of finalizing the hold on funds and posting the transaction on the cardholder's account.
This process is triggered by the merchant's capture request.
This endpoint simulates an `authorization.clearing` type transaction by including the `preceding_related_transaction_token` and `amount` in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingEvent(ctx context.Context) ApiAuthorizationClearingEventRequest {
	return ApiAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingEventExecute(r ApiAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationClearingQuasiCashEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationClearingQuasiCashEvent *AuthorizationClearingQuasiCashEvent
}

func (r ApiAuthorizationClearingQuasiCashEventRequest) AuthorizationClearingQuasiCashEvent(authorizationClearingQuasiCashEvent AuthorizationClearingQuasiCashEvent) ApiAuthorizationClearingQuasiCashEventRequest {
	r.authorizationClearingQuasiCashEvent = &authorizationClearingQuasiCashEvent
	return r
}

func (r ApiAuthorizationClearingQuasiCashEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationClearingQuasiCashEventExecute(r)
}

/*
AuthorizationClearingQuasiCashEvent Simulate quasi-cash authorization clearing

Use this endpoint to simulate `authorization.clearing.quasi.cash` transactions, which completes an authorization at a point-of-sale terminal for items equivalent to cash, such as traveler's checks, money orders, foreign currency, or gaming chips.
This simulation can be used to test dual-message quasi-cash transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationClearingQuasiCashEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingQuasiCashEvent(ctx context.Context) ApiAuthorizationClearingQuasiCashEventRequest {
	return ApiAuthorizationClearingQuasiCashEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationClearingQuasiCashEventExecute(r ApiAuthorizationClearingQuasiCashEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationClearingQuasiCashEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.clearing.quasi.cash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationClearingQuasiCashEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationEvent *AuthorizationEvent
}

func (r ApiAuthorizationEventRequest) AuthorizationEvent(authorizationEvent AuthorizationEvent) ApiAuthorizationEventRequest {
	r.authorizationEvent = &authorizationEvent
	return r
}

func (r ApiAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationEventExecute(r)
}

/*
AuthorizationEvent Simulate authorization

Authorization is the process of confirming whether a card is valid, business rules are met, and funds are sufficient, and then placing a temporary hold on those funds.
Use this endpoint to simulate an `authorization` type transaction by including the `card_token` and other authorization details in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationEvent(ctx context.Context) ApiAuthorizationEventRequest {
	return ApiAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationEventExecute(r ApiAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationIncrementalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationIncrementalEvent *AuthorizationIncrementalEvent
}

func (r ApiAuthorizationIncrementalEventRequest) AuthorizationIncrementalEvent(authorizationIncrementalEvent AuthorizationIncrementalEvent) ApiAuthorizationIncrementalEventRequest {
	r.authorizationIncrementalEvent = &authorizationIncrementalEvent
	return r
}

func (r ApiAuthorizationIncrementalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationIncrementalEventExecute(r)
}

/*
AuthorizationIncrementalEvent Simulate incremental authorization

Use this endpoint to simulate incremental authorization transactions.
An incremental authorization is a request to add an additional dollar amount to an ongoing prior authorization.
This type of transaction enables you to increase the final amount authorized as conditions change or additional charges accrue.
A common use case is adding the gratuity (an incremental authorization) to the original total (a prior authorization) of a restaurant bill.
For this use case, you use two endpoints: one to create the authorization, and another to increment it.
* Create the authorization using the `/simulations/cardtransactions/authorization` endpoint:  +
*Action:* `POST`  +
*Endpoint:* `/simulations/cardtransactions/authorization`
* Increment the authorization using the `/simulations/cardtransactions/authorization.incremental` endpoint:  +
*Action:* `POST`  +
*Endpoint:* `/simulations/cardtransactions/authorization.incremental`
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationIncrementalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationIncrementalEvent(ctx context.Context) ApiAuthorizationIncrementalEventRequest {
	return ApiAuthorizationIncrementalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationIncrementalEventExecute(r ApiAuthorizationIncrementalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationIncrementalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.incremental"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationIncrementalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationQuasiCashEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationQuasiCashEvent *AuthorizationQuasiCashEvent
}

func (r ApiAuthorizationQuasiCashEventRequest) AuthorizationQuasiCashEvent(authorizationQuasiCashEvent AuthorizationQuasiCashEvent) ApiAuthorizationQuasiCashEventRequest {
	r.authorizationQuasiCashEvent = &authorizationQuasiCashEvent
	return r
}

func (r ApiAuthorizationQuasiCashEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationQuasiCashEventExecute(r)
}

/*
AuthorizationQuasiCashEvent Simulate quasi-cash authorization

Use this endpoint to simulate `authorization.quasi.cash` transactions.
This is for authorization at a point-of-sale terminal for items equivalent to cash, such as traveler's checks, money orders, foreign currency, or gaming chips.
This simulation can be used to test dual-message quasi-cash transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationQuasiCashEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationQuasiCashEvent(ctx context.Context) ApiAuthorizationQuasiCashEventRequest {
	return ApiAuthorizationQuasiCashEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationQuasiCashEventExecute(r ApiAuthorizationQuasiCashEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationQuasiCashEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.quasi.cash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationQuasiCashEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizationReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	authorizationReversalEvent *AuthorizationReversalEvent
}

func (r ApiAuthorizationReversalEventRequest) AuthorizationReversalEvent(authorizationReversalEvent AuthorizationReversalEvent) ApiAuthorizationReversalEventRequest {
	r.authorizationReversalEvent = &authorizationReversalEvent
	return r
}

func (r ApiAuthorizationReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.AuthorizationReversalEventExecute(r)
}

/*
AuthorizationReversalEvent Simulate authorization reversal

A reversal releases the hold that was placed on account funds by an authorization, thus returning the funds to the account.
This endpoint simulates an `authorization.reversal` type transaction by including the `original_transaction_token` and `amount` in your request.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizationReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) AuthorizationReversalEvent(ctx context.Context) ApiAuthorizationReversalEventRequest {
	return ApiAuthorizationReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) AuthorizationReversalEventExecute(r ApiAuthorizationReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.AuthorizationReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/authorization.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizationReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOriginalCreditAuthPlusCaptureEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	originalCreditAuthPlusCaptureEvent *OriginalCreditAuthPlusCaptureEvent
}

func (r ApiOriginalCreditAuthPlusCaptureEventRequest) OriginalCreditAuthPlusCaptureEvent(originalCreditAuthPlusCaptureEvent OriginalCreditAuthPlusCaptureEvent) ApiOriginalCreditAuthPlusCaptureEventRequest {
	r.originalCreditAuthPlusCaptureEvent = &originalCreditAuthPlusCaptureEvent
	return r
}

func (r ApiOriginalCreditAuthPlusCaptureEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.OriginalCreditAuthPlusCaptureEventExecute(r)
}

/*
OriginalCreditAuthPlusCaptureEvent Simulate OCT authorization and capture

Use this endpoint to simulate `original.credit.auth_plus_capture` transactions for single-message original credit transaction (OCT) for disbursing funds to a credit card.
This simulation can be used to test single-message OCT transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOriginalCreditAuthPlusCaptureEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthPlusCaptureEvent(ctx context.Context) ApiOriginalCreditAuthPlusCaptureEventRequest {
	return ApiOriginalCreditAuthPlusCaptureEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthPlusCaptureEventExecute(r ApiOriginalCreditAuthPlusCaptureEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.OriginalCreditAuthPlusCaptureEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/original.credit.auth_plus_capture"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.originalCreditAuthPlusCaptureEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOriginalCreditAuthPlusCaptureReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	originalCreditAuthPlusCaptureReversalEvent *OriginalCreditAuthPlusCaptureReversalEvent
}

func (r ApiOriginalCreditAuthPlusCaptureReversalEventRequest) OriginalCreditAuthPlusCaptureReversalEvent(originalCreditAuthPlusCaptureReversalEvent OriginalCreditAuthPlusCaptureReversalEvent) ApiOriginalCreditAuthPlusCaptureReversalEventRequest {
	r.originalCreditAuthPlusCaptureReversalEvent = &originalCreditAuthPlusCaptureReversalEvent
	return r
}

func (r ApiOriginalCreditAuthPlusCaptureReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.OriginalCreditAuthPlusCaptureReversalEventExecute(r)
}

/*
OriginalCreditAuthPlusCaptureReversalEvent Simulate OCT authorization and capture reversal

Use this endpoint to simulate `original.credit.auth_plus_capture.reversal` transactions to reverse the financial impact of a single-message original credit transaction (OCT).
This simulation can be used to reverse single-message OCT transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOriginalCreditAuthPlusCaptureReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthPlusCaptureReversalEvent(ctx context.Context) ApiOriginalCreditAuthPlusCaptureReversalEventRequest {
	return ApiOriginalCreditAuthPlusCaptureReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthPlusCaptureReversalEventExecute(r ApiOriginalCreditAuthPlusCaptureReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.OriginalCreditAuthPlusCaptureReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/original.credit.auth_plus_capture.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.originalCreditAuthPlusCaptureReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOriginalCreditAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	originalCreditAuthorizationClearingEvent *OriginalCreditAuthorizationClearingEvent
}

func (r ApiOriginalCreditAuthorizationClearingEventRequest) OriginalCreditAuthorizationClearingEvent(originalCreditAuthorizationClearingEvent OriginalCreditAuthorizationClearingEvent) ApiOriginalCreditAuthorizationClearingEventRequest {
	r.originalCreditAuthorizationClearingEvent = &originalCreditAuthorizationClearingEvent
	return r
}

func (r ApiOriginalCreditAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.OriginalCreditAuthorizationClearingEventExecute(r)
}

/*
OriginalCreditAuthorizationClearingEvent Simulate OCT authorization clearing

Use this endpoint to simulate `original.credit.authorization.clearing` transactions, which completes an original credit transaction (OCT) authorization.
This simulation can be used to test dual-message OCT transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOriginalCreditAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthorizationClearingEvent(ctx context.Context) ApiOriginalCreditAuthorizationClearingEventRequest {
	return ApiOriginalCreditAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthorizationClearingEventExecute(r ApiOriginalCreditAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.OriginalCreditAuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/original.credit.authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.originalCreditAuthorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOriginalCreditAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	originalCreditAuthorizationEvent *OriginalCreditAuthorizationEvent
}

func (r ApiOriginalCreditAuthorizationEventRequest) OriginalCreditAuthorizationEvent(originalCreditAuthorizationEvent OriginalCreditAuthorizationEvent) ApiOriginalCreditAuthorizationEventRequest {
	r.originalCreditAuthorizationEvent = &originalCreditAuthorizationEvent
	return r
}

func (r ApiOriginalCreditAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.OriginalCreditAuthorizationEventExecute(r)
}

/*
OriginalCreditAuthorizationEvent Simulate OCT authorization

Use this endpoint to simulate `original.credit.authorization` transactions.
This is for original credit transaction (OCT) authorization for disbursing funds to a credit card.
This simulation can be used to test dual-message OCT transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOriginalCreditAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthorizationEvent(ctx context.Context) ApiOriginalCreditAuthorizationEventRequest {
	return ApiOriginalCreditAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) OriginalCreditAuthorizationEventExecute(r ApiOriginalCreditAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.OriginalCreditAuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/original.credit.authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.originalCreditAuthorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitAtmWithdrawalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitAtmWithdrawalEvent *PindebitAtmWithdrawalEvent
}

func (r ApiPindebitAtmWithdrawalEventRequest) PindebitAtmWithdrawalEvent(pindebitAtmWithdrawalEvent PindebitAtmWithdrawalEvent) ApiPindebitAtmWithdrawalEventRequest {
	r.pindebitAtmWithdrawalEvent = &pindebitAtmWithdrawalEvent
	return r
}

func (r ApiPindebitAtmWithdrawalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitAtmWithdrawalEventExecute(r)
}

/*
PindebitAtmWithdrawalEvent Simulate PIN-debit ATM withdrawal

Use this endpoint to simulate a cash withdrawal at an ATM.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitAtmWithdrawalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitAtmWithdrawalEvent(ctx context.Context) ApiPindebitAtmWithdrawalEventRequest {
	return ApiPindebitAtmWithdrawalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitAtmWithdrawalEventExecute(r ApiPindebitAtmWithdrawalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitAtmWithdrawalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.atm.withdrawal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitAtmWithdrawalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitAuthorizationClearingEvent *PindebitAuthorizationClearingEvent
}

func (r ApiPindebitAuthorizationClearingEventRequest) PindebitAuthorizationClearingEvent(pindebitAuthorizationClearingEvent PindebitAuthorizationClearingEvent) ApiPindebitAuthorizationClearingEventRequest {
	r.pindebitAuthorizationClearingEvent = &pindebitAuthorizationClearingEvent
	return r
}

func (r ApiPindebitAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitAuthorizationClearingEventExecute(r)
}

/*
PindebitAuthorizationClearingEvent Simulate PIN-debit authorization clearing

Use this endpoint to clear `pindebit.authorization` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitAuthorizationClearingEvent(ctx context.Context) ApiPindebitAuthorizationClearingEventRequest {
	return ApiPindebitAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitAuthorizationClearingEventExecute(r ApiPindebitAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitAuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitAuthorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitAuthorizationEvent *PindebitAuthorizationEvent
}

func (r ApiPindebitAuthorizationEventRequest) PindebitAuthorizationEvent(pindebitAuthorizationEvent PindebitAuthorizationEvent) ApiPindebitAuthorizationEventRequest {
	r.pindebitAuthorizationEvent = &pindebitAuthorizationEvent
	return r
}

func (r ApiPindebitAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitAuthorizationEventExecute(r)
}

/*
PindebitAuthorizationEvent Simulate PIN-debit authorization

Use this endpoint to simulate PIN-debit authorization transactions.
The typical use case for dual-message PIN-debit transactions is automated fuel dispenser transactions.
The pump sends an initial authorization message to the card issuer.
When fueling completes, a clearing message is sent with the final amount.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitAuthorizationEvent(ctx context.Context) ApiPindebitAuthorizationEventRequest {
	return ApiPindebitAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitAuthorizationEventExecute(r ApiPindebitAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitAuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitAuthorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitAuthorizationReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitAuthorizationReversalEvent *PindebitAuthorizationReversalEvent
}

func (r ApiPindebitAuthorizationReversalEventRequest) PindebitAuthorizationReversalEvent(pindebitAuthorizationReversalEvent PindebitAuthorizationReversalEvent) ApiPindebitAuthorizationReversalEventRequest {
	r.pindebitAuthorizationReversalEvent = &pindebitAuthorizationReversalEvent
	return r
}

func (r ApiPindebitAuthorizationReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitAuthorizationReversalEventExecute(r)
}

/*
PindebitAuthorizationReversalEvent Simulate PIN-debit authorization reversal

Use this endpoint to reverse `pindebit.authorization` transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitAuthorizationReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitAuthorizationReversalEvent(ctx context.Context) ApiPindebitAuthorizationReversalEventRequest {
	return ApiPindebitAuthorizationReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitAuthorizationReversalEventExecute(r ApiPindebitAuthorizationReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitAuthorizationReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.authorization.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitAuthorizationReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitBalanceInquiryEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitBalanceinquiryEvent *PindebitBalanceinquiryEvent
}

func (r ApiPindebitBalanceInquiryEventRequest) PindebitBalanceinquiryEvent(pindebitBalanceinquiryEvent PindebitBalanceinquiryEvent) ApiPindebitBalanceInquiryEventRequest {
	r.pindebitBalanceinquiryEvent = &pindebitBalanceinquiryEvent
	return r
}

func (r ApiPindebitBalanceInquiryEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitBalanceInquiryEventExecute(r)
}

/*
PindebitBalanceInquiryEvent Simulate PIN-debit balance inquiry

Use this endpoint to simulate a balance inquiry via the card network.
This is a non-financial transaction.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitBalanceInquiryEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitBalanceInquiryEvent(ctx context.Context) ApiPindebitBalanceInquiryEventRequest {
	return ApiPindebitBalanceInquiryEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitBalanceInquiryEventExecute(r ApiPindebitBalanceInquiryEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitBalanceInquiryEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.balanceinquiry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitBalanceinquiryEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitCashbackEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitCashbackEvent *PindebitCashbackEvent
}

func (r ApiPindebitCashbackEventRequest) PindebitCashbackEvent(pindebitCashbackEvent PindebitCashbackEvent) ApiPindebitCashbackEventRequest {
	r.pindebitCashbackEvent = &pindebitCashbackEvent
	return r
}

func (r ApiPindebitCashbackEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitCashbackEventExecute(r)
}

/*
PindebitCashbackEvent Simulate PIN-debit cash back

Simulate a PIN-debit transaction for cash back requested at a point-of-sale terminal.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitCashbackEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitCashbackEvent(ctx context.Context) ApiPindebitCashbackEventRequest {
	return ApiPindebitCashbackEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitCashbackEventExecute(r ApiPindebitCashbackEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitCashbackEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.cashback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitCashbackEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitEvent *PindebitEvent
}

func (r ApiPindebitEventRequest) PindebitEvent(pindebitEvent PindebitEvent) ApiPindebitEventRequest {
	r.pindebitEvent = &pindebitEvent
	return r
}

func (r ApiPindebitEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitEventExecute(r)
}

/*
PindebitEvent Simulate PIN-debit

Use this endpoint to simulate transactions using network debit rails.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitEvent(ctx context.Context) ApiPindebitEventRequest {
	return ApiPindebitEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitEventExecute(r ApiPindebitEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitQuasiCashEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitQuasiCashEvent *PindebitQuasiCashEvent
}

func (r ApiPindebitQuasiCashEventRequest) PindebitQuasiCashEvent(pindebitQuasiCashEvent PindebitQuasiCashEvent) ApiPindebitQuasiCashEventRequest {
	r.pindebitQuasiCashEvent = &pindebitQuasiCashEvent
	return r
}

func (r ApiPindebitQuasiCashEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitQuasiCashEventExecute(r)
}

/*
PindebitQuasiCashEvent Simulate PIN-debit quasi-cash

Use this endpoint to simulate `pindebit.quasi.cash` transactions.
This PIN-debit transaction occurs at a point-of-sale terminal for items equivalent to cash, such as traveler's checks, money orders, foreign currency, or gaming chips.
This simulation can be used to test single-message cash back transactions.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitQuasiCashEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitQuasiCashEvent(ctx context.Context) ApiPindebitQuasiCashEventRequest {
	return ApiPindebitQuasiCashEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitQuasiCashEventExecute(r ApiPindebitQuasiCashEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitQuasiCashEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.quasi.cash"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitQuasiCashEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPindebitRefundEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	pindebitRefundEvent *PindebitRefundEvent
}

func (r ApiPindebitRefundEventRequest) PindebitRefundEvent(pindebitRefundEvent PindebitRefundEvent) ApiPindebitRefundEventRequest {
	r.pindebitRefundEvent = &pindebitRefundEvent
	return r
}

func (r ApiPindebitRefundEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.PindebitRefundEventExecute(r)
}

/*
PindebitRefundEvent Simulate PIN-debit refund

Use this endpoint to simulate a PIN-debit transaction refund.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPindebitRefundEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) PindebitRefundEvent(ctx context.Context) ApiPindebitRefundEventRequest {
	return ApiPindebitRefundEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) PindebitRefundEventExecute(r ApiPindebitRefundEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.PindebitRefundEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/pindebit.refund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pindebitRefundEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundAuthorizationClearingEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundAuthorizationClearingEvent *RefundAuthorizationClearingEvent
}

func (r ApiRefundAuthorizationClearingEventRequest) RefundAuthorizationClearingEvent(refundAuthorizationClearingEvent RefundAuthorizationClearingEvent) ApiRefundAuthorizationClearingEventRequest {
	r.refundAuthorizationClearingEvent = &refundAuthorizationClearingEvent
	return r
}

func (r ApiRefundAuthorizationClearingEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundAuthorizationClearingEventExecute(r)
}

/*
RefundAuthorizationClearingEvent Simulate refund authorization clearing

Use this endpoint to simulate online refund clearing.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundAuthorizationClearingEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationClearingEvent(ctx context.Context) ApiRefundAuthorizationClearingEventRequest {
	return ApiRefundAuthorizationClearingEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationClearingEventExecute(r ApiRefundAuthorizationClearingEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundAuthorizationClearingEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund.authorization.clearing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundAuthorizationClearingEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundAuthorizationEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundAuthorizationEvent *RefundAuthorizationEvent
}

func (r ApiRefundAuthorizationEventRequest) RefundAuthorizationEvent(refundAuthorizationEvent RefundAuthorizationEvent) ApiRefundAuthorizationEventRequest {
	r.refundAuthorizationEvent = &refundAuthorizationEvent
	return r
}

func (r ApiRefundAuthorizationEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundAuthorizationEventExecute(r)
}

/*
RefundAuthorizationEvent Simulate refund authorization

Online refund refers to the `refund.authorization` messages that Visa and Mastercard merchants can send to card issuers.
These refund authorizations allow merchants to notify customers of a pending refund and give card issuers the opportunity to decline a refund.
Like purchase authorizations, refund authorizations are eventually cleared or completed by a `refund.authorization.clearing` event.
That refund authorization clearing is automatically accepted and processed by the Marqeta platform, regardless of your funding model.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundAuthorizationEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationEvent(ctx context.Context) ApiRefundAuthorizationEventRequest {
	return ApiRefundAuthorizationEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationEventExecute(r ApiRefundAuthorizationEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundAuthorizationEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund.authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundAuthorizationEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundAuthorizationReversalEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundAuthorizationReversalEvent *RefundAuthorizationReversalEvent
}

func (r ApiRefundAuthorizationReversalEventRequest) RefundAuthorizationReversalEvent(refundAuthorizationReversalEvent RefundAuthorizationReversalEvent) ApiRefundAuthorizationReversalEventRequest {
	r.refundAuthorizationReversalEvent = &refundAuthorizationReversalEvent
	return r
}

func (r ApiRefundAuthorizationReversalEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundAuthorizationReversalEventExecute(r)
}

/*
RefundAuthorizationReversalEvent Simulate refund authorization reversal

Use this endpoint to reject `refund.authorization` transactions for online refunds.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundAuthorizationReversalEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationReversalEvent(ctx context.Context) ApiRefundAuthorizationReversalEventRequest {
	return ApiRefundAuthorizationReversalEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundAuthorizationReversalEventExecute(r ApiRefundAuthorizationReversalEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundAuthorizationReversalEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund.authorization.reversal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundAuthorizationReversalEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefundEventRequest struct {
	ctx context.Context
	ApiService *SimulationsCardTransactionsAPIService
	refundEvent *RefundEvent
}

func (r ApiRefundEventRequest) RefundEvent(refundEvent RefundEvent) ApiRefundEventRequest {
	r.refundEvent = &refundEvent
	return r
}

func (r ApiRefundEventRequest) Execute() (*CardTransactionResponse, *http.Response, error) {
	return r.ApiService.RefundEventExecute(r)
}

/*
RefundEvent Simulate refund

Use this endpoint to simulate an offline refund.
Refunds are not associated with a token, so a `preceding_related_transaction_token` is not needed.
See the full request body structure at <</core-api/simulations-card-transactions#SimulationRequestBody, Request body>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefundEventRequest
*/
func (a *SimulationsCardTransactionsAPIService) RefundEvent(ctx context.Context) ApiRefundEventRequest {
	return ApiRefundEventRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CardTransactionResponse
func (a *SimulationsCardTransactionsAPIService) RefundEventExecute(r ApiRefundEventRequest) (*CardTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SimulationsCardTransactionsAPIService.RefundEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/simulations/cardtransactions/refund"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refundEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
