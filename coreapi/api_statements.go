/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// StatementsAPIService StatementsAPI service
type StatementsAPIService service

type ApiGetStatementFilesByAccountRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	startDate *time.Time
	endDate *time.Time
	count *int32
	startIndex *int32
	sortBy *string
}

// The start date of the statement files to return.
func (r ApiGetStatementFilesByAccountRequest) StartDate(startDate time.Time) ApiGetStatementFilesByAccountRequest {
	r.startDate = &startDate
	return r
}

// The end date of the statement files to return.
func (r ApiGetStatementFilesByAccountRequest) EndDate(endDate time.Time) ApiGetStatementFilesByAccountRequest {
	r.endDate = &endDate
	return r
}

// The number of resources to retrieve.
func (r ApiGetStatementFilesByAccountRequest) Count(count int32) ApiGetStatementFilesByAccountRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetStatementFilesByAccountRequest) StartIndex(startIndex int32) ApiGetStatementFilesByAccountRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
func (r ApiGetStatementFilesByAccountRequest) SortBy(sortBy string) ApiGetStatementFilesByAccountRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetStatementFilesByAccountRequest) Execute() (*StatementFilePage, *http.Response, error) {
	return r.ApiService.GetStatementFilesByAccountExecute(r)
}

/*
GetStatementFilesByAccount List files for an account

Retrieve an array of statement files for a specific credit account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which to retrieve statement files.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @return ApiGetStatementFilesByAccountRequest
*/
func (a *StatementsAPIService) GetStatementFilesByAccount(ctx context.Context, accountToken string) ApiGetStatementFilesByAccountRequest {
	return ApiGetStatementFilesByAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
	}
}

// Execute executes the request
//  @return StatementFilePage
func (a *StatementsAPIService) GetStatementFilesByAccountExecute(r ApiGetStatementFilesByAccountRequest) (*StatementFilePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementFilePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.GetStatementFilesByAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/files"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatementSummariesByAccountRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	startDate *time.Time
	endDate *time.Time
	count *int32
	startIndex *int32
	sortBy *string
}

// Returns statements with a matching opening date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
func (r ApiGetStatementSummariesByAccountRequest) StartDate(startDate time.Time) ApiGetStatementSummariesByAccountRequest {
	r.startDate = &startDate
	return r
}

// Returns statements with a matching closing date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
func (r ApiGetStatementSummariesByAccountRequest) EndDate(endDate time.Time) ApiGetStatementSummariesByAccountRequest {
	r.endDate = &endDate
	return r
}

// The number of resources to retrieve.
func (r ApiGetStatementSummariesByAccountRequest) Count(count int32) ApiGetStatementSummariesByAccountRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetStatementSummariesByAccountRequest) StartIndex(startIndex int32) ApiGetStatementSummariesByAccountRequest {
	r.startIndex = &startIndex
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
func (r ApiGetStatementSummariesByAccountRequest) SortBy(sortBy string) ApiGetStatementSummariesByAccountRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetStatementSummariesByAccountRequest) Execute() (*StatementSummaryPage, *http.Response, error) {
	return r.ApiService.GetStatementSummariesByAccountExecute(r)
}

/*
GetStatementSummariesByAccount List account statement summaries

Retrieve an array of statement summaries tied to a cardholder's account.

The statement summary, which is a summary of account activity on a statement, provides account holders with a synopsis of activity that occurred on the account during a specified billing cycle.

This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
You can use optional query parameters to return a statement based on its exact opening or closing date, or a statement whose closing date falls within a range of dates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which you want to retrieve statement summaries.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @return ApiGetStatementSummariesByAccountRequest
*/
func (a *StatementsAPIService) GetStatementSummariesByAccount(ctx context.Context, accountToken string) ApiGetStatementSummariesByAccountRequest {
	return ApiGetStatementSummariesByAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
	}
}

// Execute executes the request
//  @return StatementSummaryPage
func (a *StatementsAPIService) GetStatementSummariesByAccountExecute(r ApiGetStatementSummariesByAccountRequest) (*StatementSummaryPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementSummaryPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.GetStatementSummariesByAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStatementJournalEntriesRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
	count *int32
	startIndex *int32
	expand *string
	sortBy *string
}

// Specifies the number of journal entries to return.
func (r ApiListStatementJournalEntriesRequest) Count(count int32) ApiListStatementJournalEntriesRequest {
	r.count = &count
	return r
}

// Specifies the sort order index from which to begin returning journal entries.
func (r ApiListStatementJournalEntriesRequest) StartIndex(startIndex int32) ApiListStatementJournalEntriesRequest {
	r.startIndex = &startIndex
	return r
}

// Embeds the specified object into the response.
func (r ApiListStatementJournalEntriesRequest) Expand(expand string) ApiListStatementJournalEntriesRequest {
	r.expand = &expand
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r ApiListStatementJournalEntriesRequest) SortBy(sortBy string) ApiListStatementJournalEntriesRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiListStatementJournalEntriesRequest) Execute() (*JournalEntriesPage, *http.Response, error) {
	return r.ApiService.ListStatementJournalEntriesExecute(r)
}

/*
ListStatementJournalEntries List account statement journal entries

Retrieve an array of journal entries on a credit account's statement summary.

This endpoint supports <</core-api/sorting-and-pagination, sorting>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which to retrieve the statement journal entries.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary from which to retrieve journal entries.  Send a `GET` request to `/credit/accounts/{token}/statements/` to retrieve existing statement summary tokens.
 @return ApiListStatementJournalEntriesRequest
*/
func (a *StatementsAPIService) ListStatementJournalEntries(ctx context.Context, accountToken string, statementSummaryToken string) ApiListStatementJournalEntriesRequest {
	return ApiListStatementJournalEntriesRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return JournalEntriesPage
func (a *StatementsAPIService) ListStatementJournalEntriesExecute(r ApiListStatementJournalEntriesRequest) (*JournalEntriesPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JournalEntriesPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.ListStatementJournalEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}/journalentries"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStatementLedgerEntriesRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
	expand *string
	sortBy *string
}

// Embeds the specified object into the response.
func (r ApiListStatementLedgerEntriesRequest) Expand(expand string) ApiListStatementLedgerEntriesRequest {
	r.expand = &expand
	return r
}

// Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
func (r ApiListStatementLedgerEntriesRequest) SortBy(sortBy string) ApiListStatementLedgerEntriesRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiListStatementLedgerEntriesRequest) Execute() ([]LedgerEntry, *http.Response, error) {
	return r.ApiService.ListStatementLedgerEntriesExecute(r)
}

/*
ListStatementLedgerEntries List account statement ledger entries

[IMPORTANT]
This feature is being deprecated and replaced by statement journal entries.
To list statement journal entries, see <</core-api/credit-account-journal-entries#listStatementJournalEntries, List account statement journal entries>>.

Retrieve an array of ledger entries on a credit account's statement summary.

This endpoint supports <</core-api/sorting-and-pagination, sorting>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which to retrieve the statement ledger entries.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary from which to retrieve ledger entries.  Send a `GET` request to `/credit/accounts/{token}/statements/` to retrieve existing statement summary tokens.
 @return ApiListStatementLedgerEntriesRequest
*/
func (a *StatementsAPIService) ListStatementLedgerEntries(ctx context.Context, accountToken string, statementSummaryToken string) ApiListStatementLedgerEntriesRequest {
	return ApiListStatementLedgerEntriesRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return []LedgerEntry
func (a *StatementsAPIService) ListStatementLedgerEntriesExecute(r ApiListStatementLedgerEntriesRequest) ([]LedgerEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LedgerEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.ListStatementLedgerEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}/ledgerentries"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResendWebhookEventRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	eventType string
	resourceToken string
}

func (r ApiResendWebhookEventRequest) Execute() (*WebhookEventResendContainerResponse, *http.Response, error) {
	return r.ApiService.ResendWebhookEventExecute(r)
}

/*
ResendWebhookEvent Resend credit event notification

Resends a credit event notification to your webhook endpoint.

Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty.
The event notification is resent to your webhook endpoint and also returned in the response to this request.

For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>.
For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventType Specifies the type of event you want to resend.
 @param resourceToken The unique identifier of the resource for which you want to resend a notification.  Send a `GET` request to `/credit/accounts/{account_token}/journalentries` to retrieve existing journal entry tokens.  Send a `GET` request to `/credit/accounts/{account_token}/ledgerentries` to retrieve existing ledger entry tokens.  Send a `GET` request to `/accounts/{account_token}/accounttransitions` to retrieve existing account transition tokens.  Send a `GET` request to `/credit/accounts/{account_token}/payments/{payment_token}` to retrieve existing payment transition tokens.  Send a `GET` request to `/accounts/{account_token}/statements` to retrieve existing statement summary tokens.  Send a `GET` request to `/accounts/{account_token}/delinquencystate/transitions` to retrieve existing delinquency state transition tokens.
 @return ApiResendWebhookEventRequest
*/
func (a *StatementsAPIService) ResendWebhookEvent(ctx context.Context, eventType string, resourceToken string) ApiResendWebhookEventRequest {
	return ApiResendWebhookEventRequest{
		ApiService: a,
		ctx: ctx,
		eventType: eventType,
		resourceToken: resourceToken,
	}
}

// Execute executes the request
//  @return WebhookEventResendContainerResponse
func (a *StatementsAPIService) ResendWebhookEventExecute(r ApiResendWebhookEventRequest) (*WebhookEventResendContainerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookEventResendContainerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.ResendWebhookEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/webhooks/{event_type}/{resource_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"event_type"+"}", url.PathEscape(parameterValueToString(r.eventType, "eventType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resource_token"+"}", url.PathEscape(parameterValueToString(r.resourceToken, "resourceToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveStatementFilesRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
	count *int32
	startIndex *int32
}

// The number of statement files to return.
func (r ApiRetrieveStatementFilesRequest) Count(count int32) ApiRetrieveStatementFilesRequest {
	r.count = &count
	return r
}

// Sort order index from which to begin returning files.
func (r ApiRetrieveStatementFilesRequest) StartIndex(startIndex int32) ApiRetrieveStatementFilesRequest {
	r.startIndex = &startIndex
	return r
}

func (r ApiRetrieveStatementFilesRequest) Execute() (*StatementFilePage, *http.Response, error) {
	return r.ApiService.RetrieveStatementFilesExecute(r)
}

/*
RetrieveStatementFiles List files for a statement summary

Retrieve an array of statement files for a specific statement summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which to retrieve statement files for a statement summary.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary whose statement files you want to retrieve.  Send a `GET` request to `/credit/accounts/{token}/statements` to retrieve existing statement summary tokens.
 @return ApiRetrieveStatementFilesRequest
*/
func (a *StatementsAPIService) RetrieveStatementFiles(ctx context.Context, accountToken string, statementSummaryToken string) ApiRetrieveStatementFilesRequest {
	return ApiRetrieveStatementFilesRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return StatementFilePage
func (a *StatementsAPIService) RetrieveStatementFilesExecute(r ApiRetrieveStatementFilesRequest) (*StatementFilePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementFilePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.RetrieveStatementFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveStatementInterestChargesRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
}

func (r ApiRetrieveStatementInterestChargesRequest) Execute() (*StatementInterestChargesPage, *http.Response, error) {
	return r.ApiService.RetrieveStatementInterestChargesExecute(r)
}

/*
RetrieveStatementInterestCharges Retrieve account statement interest charges

Retrieve the interest charges on a credit account's statement summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which you want to retrieve the statement interest charges.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary from which to retrieve the interest charges.  Send a `GET` request to `/credit/accounts/{token}/statements/` to retrieve existing statement summary tokens.
 @return ApiRetrieveStatementInterestChargesRequest
*/
func (a *StatementsAPIService) RetrieveStatementInterestCharges(ctx context.Context, accountToken string, statementSummaryToken string) ApiRetrieveStatementInterestChargesRequest {
	return ApiRetrieveStatementInterestChargesRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return StatementInterestChargesPage
func (a *StatementsAPIService) RetrieveStatementInterestChargesExecute(r ApiRetrieveStatementInterestChargesRequest) (*StatementInterestChargesPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementInterestChargesPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.RetrieveStatementInterestCharges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}/interestcharges"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveStatementPaymentInfoRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
}

func (r ApiRetrieveStatementPaymentInfoRequest) Execute() (*StatementPaymentInfo, *http.Response, error) {
	return r.ApiService.RetrieveStatementPaymentInfoExecute(r)
}

/*
RetrieveStatementPaymentInfo Retrieve account statement payment information

Retrieve the payment information on a credit account's statement summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which you want to retrieve the statement payment information.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary from which to retrieve the payment information.  Send a `GET` request to `/credit/accounts/{token}/statements/` to retrieve existing statement summary tokens.
 @return ApiRetrieveStatementPaymentInfoRequest
*/
func (a *StatementsAPIService) RetrieveStatementPaymentInfo(ctx context.Context, accountToken string, statementSummaryToken string) ApiRetrieveStatementPaymentInfoRequest {
	return ApiRetrieveStatementPaymentInfoRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return StatementPaymentInfo
func (a *StatementsAPIService) RetrieveStatementPaymentInfoExecute(r ApiRetrieveStatementPaymentInfoRequest) (*StatementPaymentInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementPaymentInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.RetrieveStatementPaymentInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}/paymentinfo"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveStatementRewardRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
}

func (r ApiRetrieveStatementRewardRequest) Execute() (*StatementReward, *http.Response, error) {
	return r.ApiService.RetrieveStatementRewardExecute(r)
}

/*
RetrieveStatementReward Retrieve account statement rewards

Retrieve the rewards on a credit account's statement summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account from which to retrieve statement rewards.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary from which to retrieve rewards.  Send a `GET` request to `/credit/accounts/{token}/statements/` to retrieve existing statement summary tokens.
 @return ApiRetrieveStatementRewardRequest
*/
func (a *StatementsAPIService) RetrieveStatementReward(ctx context.Context, accountToken string, statementSummaryToken string) ApiRetrieveStatementRewardRequest {
	return ApiRetrieveStatementRewardRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return StatementReward
func (a *StatementsAPIService) RetrieveStatementRewardExecute(r ApiRetrieveStatementRewardRequest) (*StatementReward, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementReward
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.RetrieveStatementReward")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}/rewards"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveStatementSummaryRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
}

func (r ApiRetrieveStatementSummaryRequest) Execute() (*StatementSummary, *http.Response, error) {
	return r.ApiService.RetrieveStatementSummaryExecute(r)
}

/*
RetrieveStatementSummary Retrieve account statement summary

Retrieve a statement summary for a credit account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account for which you want to retrieve a statement summary.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary to retrieve.  Send a `GET` request to `/credit/accounts/{token}/statements/` to retrieve existing statement summary tokens.
 @return ApiRetrieveStatementSummaryRequest
*/
func (a *StatementsAPIService) RetrieveStatementSummary(ctx context.Context, accountToken string, statementSummaryToken string) ApiRetrieveStatementSummaryRequest {
	return ApiRetrieveStatementSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return StatementSummary
func (a *StatementsAPIService) RetrieveStatementSummaryExecute(r ApiRetrieveStatementSummaryRequest) (*StatementSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatementSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.RetrieveStatementSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveYearToDateForStatementSummaryRequest struct {
	ctx context.Context
	ApiService *StatementsAPIService
	accountToken string
	statementSummaryToken string
}

func (r ApiRetrieveYearToDateForStatementSummaryRequest) Execute() (*YearToDate, *http.Response, error) {
	return r.ApiService.RetrieveYearToDateForStatementSummaryExecute(r)
}

/*
RetrieveYearToDateForStatementSummary Retrieve account statement year-to-date totals

Retrieve the year-to-date fee and interest totals on a credit account's statement summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountToken The unique identifier of the credit account from which to retrieve statement year-to-date totals.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
 @param statementSummaryToken The unique identifier of the statement summary from which to retrieve year-to-date totals.  Send a `GET` request to `/credit/accounts/{token}/statements/` to retrieve existing statement summary tokens.
 @return ApiRetrieveYearToDateForStatementSummaryRequest
*/
func (a *StatementsAPIService) RetrieveYearToDateForStatementSummary(ctx context.Context, accountToken string, statementSummaryToken string) ApiRetrieveYearToDateForStatementSummaryRequest {
	return ApiRetrieveYearToDateForStatementSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accountToken: accountToken,
		statementSummaryToken: statementSummaryToken,
	}
}

// Execute executes the request
//  @return YearToDate
func (a *StatementsAPIService) RetrieveYearToDateForStatementSummaryExecute(r ApiRetrieveYearToDateForStatementSummaryRequest) (*YearToDate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YearToDate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatementsAPIService.RetrieveYearToDateForStatementSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/credit/accounts/{account_token}/statements/{statement_summary_token}/yeartodate"
	localVarPath = strings.Replace(localVarPath, "{"+"account_token"+"}", url.PathEscape(parameterValueToString(r.accountToken, "accountToken")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement_summary_token"+"}", url.PathEscape(parameterValueToString(r.statementSummaryToken, "statementSummaryToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
