/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marqeta_coreapi_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// UsersAPIService UsersAPI service
type UsersAPIService service

type ApiGetUsersRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	count *int32
	startIndex *int32
	searchType *string
	fields *string
	sortBy *string
}

// Number of user resources to retrieve.
func (r ApiGetUsersRequest) Count(count int32) ApiGetUsersRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetUsersRequest) StartIndex(startIndex int32) ApiGetUsersRequest {
	r.startIndex = &startIndex
	return r
}

// Search type.
func (r ApiGetUsersRequest) SearchType(searchType string) ApiGetUsersRequest {
	r.searchType = &searchType
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetUsersRequest) Fields(fields string) ApiGetUsersRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetUsersRequest) SortBy(sortBy string) ApiGetUsersRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetUsersRequest) Execute() (*UserCardHolderListResponse, *http.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
GetUsers List users

To return an array of all of a program's users, send a `GET` request to the `/users` endpoint.
This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
To narrow your result set to users that match certain criteria, see the <<search_users,Search users>> endpoint.

The `business_token` field is conditionally returned in the response (it cannot be set through the API).
You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:

[cols="1,1,1"]
|===
| parent_token | business_token | Description

| Not populated
| Not populated
| User does not have a parent.

| Populated
| Not populated
| User's parent is a user.

| Populated; matches `business_token`
| Populated; matches `parent_token`
| User's parent is a business.

| Populated; does not match `business_token`
| Populated; does not match `parent_token`
| User's parent is a user and their grandparent is a business.
|===

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersRequest
*/
func (a *UsersAPIService) GetUsers(ctx context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserCardHolderListResponse
func (a *UsersAPIService) GetUsersExecute(r ApiGetUsersRequest) (*UserCardHolderListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserCardHolderListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersAuthClientaccesstokenTokenRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	token string
	applicationToken *string
}

// Unique identifier of the &#x60;application&#x60; object.
func (r ApiGetUsersAuthClientaccesstokenTokenRequest) ApplicationToken(applicationToken string) ApiGetUsersAuthClientaccesstokenTokenRequest {
	r.applicationToken = &applicationToken
	return r
}

func (r ApiGetUsersAuthClientaccesstokenTokenRequest) Execute() (*ClientAccessTokenResponse, *http.Response, error) {
	return r.ApiService.GetUsersAuthClientaccesstokenTokenExecute(r)
}

/*
GetUsersAuthClientaccesstokenToken Retrieve client access token

To retrieve application and card information using a client access token, send a `GET` request to the `/users/auth/clientaccesstoken/{token}` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Client access token.
 @return ApiGetUsersAuthClientaccesstokenTokenRequest
*/
func (a *UsersAPIService) GetUsersAuthClientaccesstokenToken(ctx context.Context, token string) ApiGetUsersAuthClientaccesstokenTokenRequest {
	return ApiGetUsersAuthClientaccesstokenTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return ClientAccessTokenResponse
func (a *UsersAPIService) GetUsersAuthClientaccesstokenTokenExecute(r ApiGetUsersAuthClientaccesstokenTokenRequest) (*ClientAccessTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientAccessTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUsersAuthClientaccesstokenToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/clientaccesstoken/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.applicationToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "application_token", r.applicationToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersParenttokenChildrenRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	parentToken string
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
}

// Number of user resources to retrieve.
func (r ApiGetUsersParenttokenChildrenRequest) Count(count int32) ApiGetUsersParenttokenChildrenRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetUsersParenttokenChildrenRequest) StartIndex(startIndex int32) ApiGetUsersParenttokenChildrenRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetUsersParenttokenChildrenRequest) Fields(fields string) ApiGetUsersParenttokenChildrenRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetUsersParenttokenChildrenRequest) SortBy(sortBy string) ApiGetUsersParenttokenChildrenRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetUsersParenttokenChildrenRequest) Execute() (*UserCardHolderListResponse, *http.Response, error) {
	return r.ApiService.GetUsersParenttokenChildrenExecute(r)
}

/*
GetUsersParenttokenChildren List user child accounts

To retrieve users who are children of a parent user or business, send a `GET` request to the `/users/{parent_token}/children` endpoint.
Include the parent's user or business token as a URL path parameter.

The `business_token` field is conditionally returned in the response (it cannot be set through the API).
You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:

[cols="1,1,1"]
|===
| parent_token | business_token | Description

| Not populated
| Not populated
| User does not have a parent.

| Populated
| Not populated
| User's parent is a user.

| Populated; matches `business_token`
| Populated; matches `parent_token`
| User's parent is a business.

| Populated; does not match `business_token`
| Populated; does not match `parent_token`
| User's parent is a user and their grandparent is a business.
|===

This endpoint supports <</core-api/field-filtering, field filtering>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentToken Unique identifier of the parent account holder.
 @return ApiGetUsersParenttokenChildrenRequest
*/
func (a *UsersAPIService) GetUsersParenttokenChildren(ctx context.Context, parentToken string) ApiGetUsersParenttokenChildrenRequest {
	return ApiGetUsersParenttokenChildrenRequest{
		ApiService: a,
		ctx: ctx,
		parentToken: parentToken,
	}
}

// Execute executes the request
//  @return UserCardHolderListResponse
func (a *UsersAPIService) GetUsersParenttokenChildrenExecute(r ApiGetUsersParenttokenChildrenRequest) (*UserCardHolderListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserCardHolderListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUsersParenttokenChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{parent_token}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_token"+"}", url.PathEscape(parameterValueToString(r.parentToken, "parentToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersTokenRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	token string
	fields *string
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetUsersTokenRequest) Fields(fields string) ApiGetUsersTokenRequest {
	r.fields = &fields
	return r
}

func (r ApiGetUsersTokenRequest) Execute() (*UserCardHolderResponse, *http.Response, error) {
	return r.ApiService.GetUsersTokenExecute(r)
}

/*
GetUsersToken Retrieve user

To retrieve a specific user, send a `GET` request to the `/users/{token}` endpoint.
Include the user `token` path parameter to specify the user to return.

The `business_token` field is conditionally returned in the response (it cannot be set through the API).
You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:

[cols="1,1,1"]
|===
| parent_token | business_token | Description

| Not populated
| Not populated
| User does not have a parent.

| Populated
| Not populated
| User's parent is a user.

| Populated; matches `business_token`
| Populated; matches `parent_token`
| User's parent is a business.

| Populated; does not match `business_token`
| Populated; does not match `parent_token`
| User's parent is a user and their grandparent is a business.
|===

This endpoint supports <</core-api/field-filtering, field filtering>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the user resource.
 @return ApiGetUsersTokenRequest
*/
func (a *UsersAPIService) GetUsersToken(ctx context.Context, token string) ApiGetUsersTokenRequest {
	return ApiGetUsersTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return UserCardHolderResponse
func (a *UsersAPIService) GetUsersTokenExecute(r ApiGetUsersTokenRequest) (*UserCardHolderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserCardHolderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUsersToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersTokenSsnRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	token string
	fullSsn *bool
}

// To return the full identification number, set to &#x60;true&#x60;. To return only the last four digits, set to &#x60;false&#x60;.  If the identifications array contains only the last four digits of the identification number, the &#x60;/users/{token}/ssn&#x60; endpoint will return only the last four digits, regardless of the &#x60;full_ssn&#x60; parameter.
func (r ApiGetUsersTokenSsnRequest) FullSsn(fullSsn bool) ApiGetUsersTokenSsnRequest {
	r.fullSsn = &fullSsn
	return r
}

func (r ApiGetUsersTokenSsnRequest) Execute() (*SsnResponseModel, *http.Response, error) {
	return r.ApiService.GetUsersTokenSsnExecute(r)
}

/*
GetUsersTokenSsn Retrieve user identification number

To retrieve the government-issued identification number for a user, send a `GET` request to the `/users/{token}/ssn` endpoint.
Include the `token` path parameter to specify the user whose identification number (SSN, TIN, NIN, SIN) you wish to return.
You can indicate whether to return the full number or the last four digits only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the user resource.
 @return ApiGetUsersTokenSsnRequest
*/
func (a *UsersAPIService) GetUsersTokenSsn(ctx context.Context, token string) ApiGetUsersTokenSsnRequest {
	return ApiGetUsersTokenSsnRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return SsnResponseModel
func (a *UsersAPIService) GetUsersTokenSsnExecute(r ApiGetUsersTokenSsnRequest) (*SsnResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SsnResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.GetUsersTokenSsn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{token}/ssn"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fullSsn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_ssn", r.fullSsn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	cardHolderModel *CardHolderModel
}

func (r ApiPostUsersRequest) CardHolderModel(cardHolderModel CardHolderModel) ApiPostUsersRequest {
	r.cardHolderModel = &cardHolderModel
	return r
}

func (r ApiPostUsersRequest) Execute() (*UserCardHolderResponse, *http.Response, error) {
	return r.ApiService.PostUsersExecute(r)
}

/*
PostUsers Create user

This endpoint enables you to create a user.
A new user's initial status depends on the <</core-api/kyc-verification, Know Your Customer (KYC) requirements>> of the program or associated <</core-api/account-holder-groups, account holder group>>.

[cols="1,1,1,1"]
|===
| KYC Required | Initial User Status | User Active on Creation | User Limitations

| Always
| `UNVERIFIED`
| Optional
| Cannot load funds; cannot activate cards.

| Conditionally
| `LIMITED`
| Optional
| Restricted by rules in `accountholdergroups.pre_kyc_controls`.

| Never
| `ACTIVE`
| Required
| None.
|===

[NOTE]
Use the `/usertransitions` endpoints to transition user resources between statuses and to view the history of a user's status.
Do not set the value of the `user.active` field directly.
For more information on status changes, see <</core-api/user-transitions#postUsertransitions, Create User Transition>>.

To perform KYC verification on users, the user object must have the following fields configured:

* `first_name`
* `last_name`
* `address1` (cannot be a PO Box)
* `city`
* `state`
* `postal_code`
* `country`
* `birth_date`
* `identifications`
* `phone` (required in some cases)
* `email` (required in some cases)

[NOTE]
The `identifications` requirement depends on your program's configuration.
To determine if you should provide a full or abbreviated identification number, contact your Marqeta representative.
KYC verification requires the full Social Security Number (SSN) of the user.

To create a child user, you must identify the parent user or business and determine whether the child user shares an account with the parent.

The parent must be an existing user or business.
On the child user, set the `parent_token` field to the value of the parent's `token` field.
If either the parent or the grandparent is a business, a `business_token` field is added to the user.
This field's value is set to the token of either the parent or grandparent (whichever is the business).

The `uses_parent_account` field determines whether the child shares balances with the parent (`true`) or whether the child balances are independent of the parent (`false`).
If you do not specify a value for `uses_parent_account`, it is set to `false` by default (the user does not share the parent's balance) and returned in the response body.
This field cannot be updated, so you must decide upon creation whether the child user shares the parent balance.

Sharing an account with a parent user affects how the child user interacts with cards as follows:

* A child user cannot spend funds if its parent is not active.
* An active child user can activate cards, whether the parent is active or not.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersRequest
*/
func (a *UsersAPIService) PostUsers(ctx context.Context) ApiPostUsersRequest {
	return ApiPostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserCardHolderResponse
func (a *UsersAPIService) PostUsersExecute(r ApiPostUsersRequest) (*UserCardHolderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserCardHolderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cardHolderModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersAuthChangepasswordRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	passwordUpdateModel *PasswordUpdateModel
}

// Password update object
func (r ApiPostUsersAuthChangepasswordRequest) PasswordUpdateModel(passwordUpdateModel PasswordUpdateModel) ApiPostUsersAuthChangepasswordRequest {
	r.passwordUpdateModel = &passwordUpdateModel
	return r
}

func (r ApiPostUsersAuthChangepasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersAuthChangepasswordExecute(r)
}

/*
PostUsersAuthChangepassword Update user password

To change a user password, send a `POST` request to the `/users/auth/changepassword` endpoint and include the `current_password` and `new_password` in link:http://www.json.org/[JSON, window="_blank"] format in the body of the request.
This endpoint operates in the context of a currently logged-in user.

A successful password change returns an empty response body with a response code of `204 No Content`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthChangepasswordRequest
*/
func (a *UsersAPIService) PostUsersAuthChangepassword(ctx context.Context) ApiPostUsersAuthChangepasswordRequest {
	return ApiPostUsersAuthChangepasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) PostUsersAuthChangepasswordExecute(r ApiPostUsersAuthChangepasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthChangepassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/changepassword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.passwordUpdateModel == nil {
		return nil, reportError("passwordUpdateModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.passwordUpdateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersAuthClientaccesstokenRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	clientAccessTokenRequest *ClientAccessTokenRequest
}

func (r ApiPostUsersAuthClientaccesstokenRequest) ClientAccessTokenRequest(clientAccessTokenRequest ClientAccessTokenRequest) ApiPostUsersAuthClientaccesstokenRequest {
	r.clientAccessTokenRequest = &clientAccessTokenRequest
	return r
}

func (r ApiPostUsersAuthClientaccesstokenRequest) Execute() (*ClientAccessTokenResponse, *http.Response, error) {
	return r.ApiService.PostUsersAuthClientaccesstokenExecute(r)
}

/*
PostUsersAuthClientaccesstoken Create client access token

Each time you want to display a virtual card's sensitive data (for example, when using `marqeta.js`), you must first request a new, single-use client access token from the Marqeta platform by sending a `POST` request to the `/users/auth/clientaccesstoken` endpoint.
Unredeemed client access tokens expire after five minutes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthClientaccesstokenRequest
*/
func (a *UsersAPIService) PostUsersAuthClientaccesstoken(ctx context.Context) ApiPostUsersAuthClientaccesstokenRequest {
	return ApiPostUsersAuthClientaccesstokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClientAccessTokenResponse
func (a *UsersAPIService) PostUsersAuthClientaccesstokenExecute(r ApiPostUsersAuthClientaccesstokenRequest) (*ClientAccessTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClientAccessTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthClientaccesstoken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/clientaccesstoken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientAccessTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersAuthLoginRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	loginRequestModel *LoginRequestModel
}

// User login object
func (r ApiPostUsersAuthLoginRequest) LoginRequestModel(loginRequestModel LoginRequestModel) ApiPostUsersAuthLoginRequest {
	r.loginRequestModel = &loginRequestModel
	return r
}

func (r ApiPostUsersAuthLoginRequest) Execute() (*LoginResponseModel, *http.Response, error) {
	return r.ApiService.PostUsersAuthLoginExecute(r)
}

/*
PostUsersAuthLogin Log in user

To log in a user and return a user access token, send a `POST` request to the `/users/auth/login` endpoint and include the user details in link:http://www.json.org/[JSON, window="_blank"] format in the body of the request.

[TIP]
To check a user's credentials without logging out the user, call the `/users/auth/onetime` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthLoginRequest
*/
func (a *UsersAPIService) PostUsersAuthLogin(ctx context.Context) ApiPostUsersAuthLoginRequest {
	return ApiPostUsersAuthLoginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LoginResponseModel
func (a *UsersAPIService) PostUsersAuthLoginExecute(r ApiPostUsersAuthLoginRequest) (*LoginResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LoginResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.loginRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersAuthLogoutRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
}

func (r ApiPostUsersAuthLogoutRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersAuthLogoutExecute(r)
}

/*
PostUsersAuthLogout Log out user

To log out a user, send a `POST` request to the `/users/auth/logout` endpoint.

A successful logout returns an empty response body with a response code of `204 No Content`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthLogoutRequest
*/
func (a *UsersAPIService) PostUsersAuthLogout(ctx context.Context) ApiPostUsersAuthLogoutRequest {
	return ApiPostUsersAuthLogoutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) PostUsersAuthLogoutExecute(r ApiPostUsersAuthLogoutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthLogout")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersAuthOnetimeRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	oneTimeRequestModel *OneTimeRequestModel
}

// One-time object
func (r ApiPostUsersAuthOnetimeRequest) OneTimeRequestModel(oneTimeRequestModel OneTimeRequestModel) ApiPostUsersAuthOnetimeRequest {
	r.oneTimeRequestModel = &oneTimeRequestModel
	return r
}

func (r ApiPostUsersAuthOnetimeRequest) Execute() (*AccessTokenResponse, *http.Response, error) {
	return r.ApiService.PostUsersAuthOnetimeExecute(r)
}

/*
PostUsersAuthOnetime Create single-use token

This endpoint returns a single-use access token.
This type of token authorizes a single request to access API endpoints and data associated with a particular user.
A single-use access token differs from a user access token (as returned by `POST` `/users/auth/login`) only in the number of times it can be used.

To return a single-use access token, send a `POST` request to the `/users/auth/onetime` endpoint.
Provide one of these sets of input data:

* *Case #1* – Application token and user access token
* *Case #2* – Application token, admin access token, and user token
* *Case #3* – Application token, user's Marqeta password, and user's email address

In each case, provide the application token as the HTTP Basic Authentication username in the request header's Authorization field.
When applicable, provide the user access token or admin access token as the HTTP Basic Authentication password.
When applicable, provide the user token or user's Marqeta password and email address in link:http://www.json.org/[JSON, window="_blank"] format in the request body.

Before instantiating an embedded Marqeta widget, call this endpoint to obtain the single-use access token required as input (cases #1 and #2).

This endpoint is also useful when you want to check a user's credentials before performing a sensitive operation without having to log out the user (case #3).

[NOTE]
Calling this endpoint and returning a single-use access token does not invalidate the user's current user access token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthOnetimeRequest
*/
func (a *UsersAPIService) PostUsersAuthOnetime(ctx context.Context) ApiPostUsersAuthOnetimeRequest {
	return ApiPostUsersAuthOnetimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessTokenResponse
func (a *UsersAPIService) PostUsersAuthOnetimeExecute(r ApiPostUsersAuthOnetimeRequest) (*AccessTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthOnetime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/onetime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oneTimeRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUsersAuthResetpasswordRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	resetUserPasswordEmailModel *ResetUserPasswordEmailModel
}

func (r ApiPostUsersAuthResetpasswordRequest) ResetUserPasswordEmailModel(resetUserPasswordEmailModel ResetUserPasswordEmailModel) ApiPostUsersAuthResetpasswordRequest {
	r.resetUserPasswordEmailModel = &resetUserPasswordEmailModel
	return r
}

func (r ApiPostUsersAuthResetpasswordRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersAuthResetpasswordExecute(r)
}

/*
PostUsersAuthResetpassword Request user password reset token

Use this endpoint to generate a password reset token for a user.
Send a `POST` request to the `/users/auth/resetpassword` endpoint and include the user's email address in link:http://www.json.org/[JSON, window="_blank"] format in the body of the request.
This request generates and sends an email message containing the `user_token` and `password_reset_token` to the user's email address.
You must customize the email message with a link that passes the `user_token` and `password_reset_token` to a web page where a subsequent request updates the password.

A successful request returns an empty response body with a response code of `204 No Content`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthResetpasswordRequest
*/
func (a *UsersAPIService) PostUsersAuthResetpassword(ctx context.Context) ApiPostUsersAuthResetpasswordRequest {
	return ApiPostUsersAuthResetpasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) PostUsersAuthResetpasswordExecute(r ApiPostUsersAuthResetpasswordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthResetpassword")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/resetpassword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resetUserPasswordEmailModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersAuthResetpasswordTokenRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	token string
	resetUserPasswordModel *ResetUserPasswordModel
}

func (r ApiPostUsersAuthResetpasswordTokenRequest) ResetUserPasswordModel(resetUserPasswordModel ResetUserPasswordModel) ApiPostUsersAuthResetpasswordTokenRequest {
	r.resetUserPasswordModel = &resetUserPasswordModel
	return r
}

func (r ApiPostUsersAuthResetpasswordTokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersAuthResetpasswordTokenExecute(r)
}

/*
PostUsersAuthResetpasswordToken Reset user password

To reset the user's password, send a `POST` request to the `/users/auth/resetpassword/{token}` endpoint that includes a password reset token generated using the `POST /users/auth/resetpassword` operation.
Include the `user_token` and `new_password` in link:http://www.json.org/[JSON, window="_blank"] format in the body of the request.
Include the `password_reset_token` as a path parameter.

A successful password reset returns an empty response body with a response code of `204 No Content`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Password reset token generated using the `POST /users/auth/resetpassword` operation.
 @return ApiPostUsersAuthResetpasswordTokenRequest
*/
func (a *UsersAPIService) PostUsersAuthResetpasswordToken(ctx context.Context, token string) ApiPostUsersAuthResetpasswordTokenRequest {
	return ApiPostUsersAuthResetpasswordTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
func (a *UsersAPIService) PostUsersAuthResetpasswordTokenExecute(r ApiPostUsersAuthResetpasswordTokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthResetpasswordToken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/resetpassword/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resetUserPasswordModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersAuthVerifyemailRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
}

func (r ApiPostUsersAuthVerifyemailRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersAuthVerifyemailExecute(r)
}

/*
PostUsersAuthVerifyemail Request email verification token

Send a `POST` request to the `/users/auth/verifyemail` endpoint to request an email verification token.
No input parameters are required because this operation is performed in the context of an authenticated user.

This initial request generates and sends an email message containing the email verification token to the cardholder's email address.
This email message must include a link that passes the email verification token to a web page where a subsequent request verifies the email address.

A successful request returns an empty response body with a response code of `204 No Content`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersAuthVerifyemailRequest
*/
func (a *UsersAPIService) PostUsersAuthVerifyemail(ctx context.Context) ApiPostUsersAuthVerifyemailRequest {
	return ApiPostUsersAuthVerifyemailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UsersAPIService) PostUsersAuthVerifyemailExecute(r ApiPostUsersAuthVerifyemailRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthVerifyemail")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/verifyemail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersAuthVerifyemailTokenRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	token string
}

func (r ApiPostUsersAuthVerifyemailTokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUsersAuthVerifyemailTokenExecute(r)
}

/*
PostUsersAuthVerifyemailToken Verify email address

To verify a user's email address, send a `POST` request to the `/users/auth/verifyemail/{email_verification_token}` endpoint that includes an `email_verification_token` generated using the `POST /users/auth/verifyemail` operation.
Include the `email_verification_token` as a path parameter.

A successful email verification returns an empty response body with a response code of `204 No Content`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Email verification token generated using the `POST /users/auth/verifyemail` operation.
 @return ApiPostUsersAuthVerifyemailTokenRequest
*/
func (a *UsersAPIService) PostUsersAuthVerifyemailToken(ctx context.Context, token string) ApiPostUsersAuthVerifyemailTokenRequest {
	return ApiPostUsersAuthVerifyemailTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
func (a *UsersAPIService) PostUsersAuthVerifyemailTokenExecute(r ApiPostUsersAuthVerifyemailTokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersAuthVerifyemailToken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/auth/verifyemail/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUsersLookupRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	count *int32
	startIndex *int32
	searchType *string
	fields *string
	sortBy *string
	userCardHolderSearchModel *UserCardHolderSearchModel
}

// Number of user resources to retrieve.
func (r ApiPostUsersLookupRequest) Count(count int32) ApiPostUsersLookupRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiPostUsersLookupRequest) StartIndex(startIndex int32) ApiPostUsersLookupRequest {
	r.startIndex = &startIndex
	return r
}

// Search type.
func (r ApiPostUsersLookupRequest) SearchType(searchType string) ApiPostUsersLookupRequest {
	r.searchType = &searchType
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiPostUsersLookupRequest) Fields(fields string) ApiPostUsersLookupRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiPostUsersLookupRequest) SortBy(sortBy string) ApiPostUsersLookupRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiPostUsersLookupRequest) UserCardHolderSearchModel(userCardHolderSearchModel UserCardHolderSearchModel) ApiPostUsersLookupRequest {
	r.userCardHolderSearchModel = &userCardHolderSearchModel
	return r
}

func (r ApiPostUsersLookupRequest) Execute() (*UserCardHolderListResponse, *http.Response, error) {
	return r.ApiService.PostUsersLookupExecute(r)
}

/*
PostUsersLookup Search users

To search for one or more users, send a `POST` request to the `/users/lookup` endpoint.
Include in the message body any parameters by which you want to query.
This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUsersLookupRequest
*/
func (a *UsersAPIService) PostUsersLookup(ctx context.Context) ApiPostUsersLookupRequest {
	return ApiPostUsersLookupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserCardHolderListResponse
func (a *UsersAPIService) PostUsersLookupExecute(r ApiPostUsersLookupRequest) (*UserCardHolderListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserCardHolderListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PostUsersLookup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/lookup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.searchType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_type", r.searchType, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-lastModifiedTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userCardHolderSearchModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUsersTokenRequest struct {
	ctx context.Context
	ApiService *UsersAPIService
	token string
	userCardHolderUpdateModel *UserCardHolderUpdateModel
}

// User object
func (r ApiPutUsersTokenRequest) UserCardHolderUpdateModel(userCardHolderUpdateModel UserCardHolderUpdateModel) ApiPutUsersTokenRequest {
	r.userCardHolderUpdateModel = &userCardHolderUpdateModel
	return r
}

func (r ApiPutUsersTokenRequest) Execute() (*CardHolderModel, *http.Response, error) {
	return r.ApiService.PutUsersTokenExecute(r)
}

/*
PutUsersToken Update user

To update a specific user resource, send a `PUT` request to the `/users/{token}` endpoint.
Include the user `token` path parameter to specify the user to update.

To unlink a child user account from a parent account, pass a null value to the `parent_token` field of the child user resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the user resource you want to update.
 @return ApiPutUsersTokenRequest
*/
func (a *UsersAPIService) PutUsersToken(ctx context.Context, token string) ApiPutUsersTokenRequest {
	return ApiPutUsersTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return CardHolderModel
func (a *UsersAPIService) PutUsersTokenExecute(r ApiPutUsersTokenRequest) (*CardHolderModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CardHolderModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersAPIService.PutUsersToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userCardHolderUpdateModel == nil {
		return localVarReturnValue, nil, reportError("userCardHolderUpdateModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userCardHolderUpdateModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
