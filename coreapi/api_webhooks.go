/*
Core API

Marqeta's Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.

API version: 3.0.11
Contact: support@marqeta.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package coreapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// WebhooksAPIService WebhooksAPI service
type WebhooksAPIService service

type ApiGetWebhooksRequest struct {
	ctx context.Context
	ApiService *WebhooksAPIService
	active *bool
	count *int32
	startIndex *int32
	fields *string
	sortBy *string
}

// Set to &#x60;true&#x60; to return only active webhook configurations.
func (r ApiGetWebhooksRequest) Active(active bool) ApiGetWebhooksRequest {
	r.active = &active
	return r
}

// Number of resources to retrieve.
func (r ApiGetWebhooksRequest) Count(count int32) ApiGetWebhooksRequest {
	r.count = &count
	return r
}

// Sort order index of the first resource in the returned array.
func (r ApiGetWebhooksRequest) StartIndex(startIndex int32) ApiGetWebhooksRequest {
	r.startIndex = &startIndex
	return r
}

// Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
func (r ApiGetWebhooksRequest) Fields(fields string) ApiGetWebhooksRequest {
	r.fields = &fields
	return r
}

// Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
func (r ApiGetWebhooksRequest) SortBy(sortBy string) ApiGetWebhooksRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetWebhooksRequest) Execute() (*WebhookResponseModelListResponse, *http.Response, error) {
	return r.ApiService.GetWebhooksExecute(r)
}

/*
GetWebhooks List webhooks

Returns an array of all webhooks.

This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, sorting>>, and <</core-api/sorting-and-pagination, pagination>>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWebhooksRequest
*/
func (a *WebhooksAPIService) GetWebhooks(ctx context.Context) ApiGetWebhooksRequest {
	return ApiGetWebhooksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebhookResponseModelListResponse
func (a *WebhooksAPIService) GetWebhooksExecute(r ApiGetWebhooksRequest) (*WebhookResponseModelListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookResponseModelListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhooksAPIService.GetWebhooks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	} else {
		var defaultValue bool = false
		r.active = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 5
		r.count = &defaultValue
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	} else {
		var defaultValue string = "-createdTime"
		r.sortBy = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhooksTokenRequest struct {
	ctx context.Context
	ApiService *WebhooksAPIService
	token string
}

func (r ApiGetWebhooksTokenRequest) Execute() (*WebhookResponseModel, *http.Response, error) {
	return r.ApiService.GetWebhooksTokenExecute(r)
}

/*
GetWebhooksToken Retrieve webhook

Retrieves a webhook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the webhook.
 @return ApiGetWebhooksTokenRequest
*/
func (a *WebhooksAPIService) GetWebhooksToken(ctx context.Context, token string) ApiGetWebhooksTokenRequest {
	return ApiGetWebhooksTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return WebhookResponseModel
func (a *WebhooksAPIService) GetWebhooksTokenExecute(r ApiGetWebhooksTokenRequest) (*WebhookResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhooksAPIService.GetWebhooksToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostWebhooksRequest struct {
	ctx context.Context
	ApiService *WebhooksAPIService
	webhookRequestModel *WebhookRequestModel
}

func (r ApiPostWebhooksRequest) WebhookRequestModel(webhookRequestModel WebhookRequestModel) ApiPostWebhooksRequest {
	r.webhookRequestModel = &webhookRequestModel
	return r
}

func (r ApiPostWebhooksRequest) Execute() (*WebhookResponseModel, *http.Response, error) {
	return r.ApiService.PostWebhooksExecute(r)
}

/*
PostWebhooks Create webhook

Creates a webhook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostWebhooksRequest
*/
func (a *WebhooksAPIService) PostWebhooks(ctx context.Context) ApiPostWebhooksRequest {
	return ApiPostWebhooksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebhookResponseModel
func (a *WebhooksAPIService) PostWebhooksExecute(r ApiPostWebhooksRequest) (*WebhookResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhooksAPIService.PostWebhooks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostWebhooksTokenEventtypeEventtokenRequest struct {
	ctx context.Context
	ApiService *WebhooksAPIService
	token string
	eventType string
	eventToken string
}

func (r ApiPostWebhooksTokenEventtypeEventtokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostWebhooksTokenEventtypeEventtokenExecute(r)
}

/*
PostWebhooksTokenEventtypeEventtoken Resend event notification

Resends an event notification to your webhook endpoint.

Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty.
The event notification is resent to your webhook endpoint and is also returned in the response to this request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the webhook.
 @param eventType Specifies the type of event you want to resend.
 @param eventToken Unique identifier of the event for which you want to resend a notification.
 @return ApiPostWebhooksTokenEventtypeEventtokenRequest
*/
func (a *WebhooksAPIService) PostWebhooksTokenEventtypeEventtoken(ctx context.Context, token string, eventType string, eventToken string) ApiPostWebhooksTokenEventtypeEventtokenRequest {
	return ApiPostWebhooksTokenEventtypeEventtokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
		eventType: eventType,
		eventToken: eventToken,
	}
}

// Execute executes the request
func (a *WebhooksAPIService) PostWebhooksTokenEventtypeEventtokenExecute(r ApiPostWebhooksTokenEventtypeEventtokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhooksAPIService.PostWebhooksTokenEventtypeEventtoken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks/{token}/{event_type}/{event_token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event_type"+"}", url.PathEscape(parameterValueToString(r.eventType, "eventType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event_token"+"}", url.PathEscape(parameterValueToString(r.eventToken, "eventToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostWebhooksTokenPingRequest struct {
	ctx context.Context
	ApiService *WebhooksAPIService
	token string
}

func (r ApiPostWebhooksTokenPingRequest) Execute() (*WebhookPingModel, *http.Response, error) {
	return r.ApiService.PostWebhooksTokenPingExecute(r)
}

/*
PostWebhooksTokenPing Ping webhook

Pings your webhook endpoint.

Send a ping request to your webhook endpoint to validate credentials and connectivity.
Your webhook endpoint must be configured to respond.

=== Configuring your webhook endpoint

When the Marqeta platform receives the ping request, it sends a `POST` request containing the following body to the URL of your webhook endpoint:

[#ping-webhook-sample]
[source,json]
----
{
  "pings": [
    {
      "token": "marqeta",
      "payload": "healthcheck"
    }
  ]
}
----

To indicate that it is functioning properly, your webhook endpoint must respond with a status code of `200` (see <</developer-guides/signature-verification, Signature Verification>> for a code example that identifies a ping request).
The response can optionally include a link:http://www.json.org/[JSON, window="_blank"]-formatted body, for example:

[#ping-webhook-sample-2]
[source,json]
----
{"my_endpoint_status": "alive"}
----

The Marqeta platform then responds to its requestor by echoing, as-is, the response code and body received from your webhook endpoint.

=== Using the ping facility

To ping a webhook endpoint, send a `POST` request to `/webhooks/{token}/ping` and use the `token` path parameter to specify which webhook you want to reach.
Include an empty, link:http://www.json.org/[JSON, window="_blank"]-formatted body in the request, that is:

[#ping-webhook-sample-3]
[source,json]
----
{}
----

The following chain of actions occurs during the successful execution of a ping operation:

. The Marqeta platform receives the ping request (`POST` to `/webhooks/{token}/ping`).
. The Marqeta platform sends a request to your webhook endpoint.
. Your webhook endpoint responds with a status code of "200" and an optional body.
. The Marqeta platform responds to its requestor by echoing, as-is, the response code and body it received from your webhook endpoint.

[NOTE]
If the customer-hosted endpoint fails to respond within five seconds, the Marqeta platform times out the request and responds with the following message body (where `<optional message>` represents additional details you can choose to include in the response):

[#ping-webhook-sample-4]
[source,json]
----
{
  "error_message": "Webhook operation failed " + <optional message>,
  "error_code": "422600"
}
----

Failed pings are not automatically retried.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the webhook.
 @return ApiPostWebhooksTokenPingRequest
*/
func (a *WebhooksAPIService) PostWebhooksTokenPing(ctx context.Context, token string) ApiPostWebhooksTokenPingRequest {
	return ApiPostWebhooksTokenPingRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return WebhookPingModel
func (a *WebhooksAPIService) PostWebhooksTokenPingExecute(r ApiPostWebhooksTokenPingRequest) (*WebhookPingModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookPingModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhooksAPIService.PostWebhooksTokenPing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks/{token}/ping"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutWebhooksCustomHeadersTokenRequest struct {
	ctx context.Context
	ApiService *WebhooksAPIService
	token string
	webhookUpdateCustomHeaderRequest *WebhookUpdateCustomHeaderRequest
}

func (r ApiPutWebhooksCustomHeadersTokenRequest) WebhookUpdateCustomHeaderRequest(webhookUpdateCustomHeaderRequest WebhookUpdateCustomHeaderRequest) ApiPutWebhooksCustomHeadersTokenRequest {
	r.webhookUpdateCustomHeaderRequest = &webhookUpdateCustomHeaderRequest
	return r
}

func (r ApiPutWebhooksCustomHeadersTokenRequest) Execute() (*WebhookResponseModel, *http.Response, error) {
	return r.ApiService.PutWebhooksCustomHeadersTokenExecute(r)
}

/*
PutWebhooksCustomHeadersToken Update webhook custom headers

Adds or updates a webhook's custom HTTP headers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the webhook.
 @return ApiPutWebhooksCustomHeadersTokenRequest
*/
func (a *WebhooksAPIService) PutWebhooksCustomHeadersToken(ctx context.Context, token string) ApiPutWebhooksCustomHeadersTokenRequest {
	return ApiPutWebhooksCustomHeadersTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return WebhookResponseModel
func (a *WebhooksAPIService) PutWebhooksCustomHeadersTokenExecute(r ApiPutWebhooksCustomHeadersTokenRequest) (*WebhookResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhooksAPIService.PutWebhooksCustomHeadersToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks/customheaders/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookUpdateCustomHeaderRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutWebhooksTokenRequest struct {
	ctx context.Context
	ApiService *WebhooksAPIService
	token string
	webhookBaseModel *WebhookBaseModel
}

func (r ApiPutWebhooksTokenRequest) WebhookBaseModel(webhookBaseModel WebhookBaseModel) ApiPutWebhooksTokenRequest {
	r.webhookBaseModel = &webhookBaseModel
	return r
}

func (r ApiPutWebhooksTokenRequest) Execute() (*WebhookResponseModel, *http.Response, error) {
	return r.ApiService.PutWebhooksTokenExecute(r)
}

/*
PutWebhooksToken Update webhook

Updates a webhook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token Unique identifier of the webhook.
 @return ApiPutWebhooksTokenRequest
*/
func (a *WebhooksAPIService) PutWebhooksToken(ctx context.Context, token string) ApiPutWebhooksTokenRequest {
	return ApiPutWebhooksTokenRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return WebhookResponseModel
func (a *WebhooksAPIService) PutWebhooksTokenExecute(r ApiPutWebhooksTokenRequest) (*WebhookResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhooksAPIService.PutWebhooksToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/webhooks/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookBaseModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
